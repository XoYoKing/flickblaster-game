// Generated by CoffeeScript 1.6.1
(function() {
  var BaseItem, Sprite, SpriteRenderer, assets, gameConfig, gameData, renderer,
    _this = this,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  renderer = require('../../core/renderer');

  BaseItem = require('./BaseItem');

  SpriteRenderer = require('../utils/SpriteRenderer');

  gameData = require('../utils/gameData');

  assets = require('../utils/assets');

  gameConfig = require('../config');

  /*
  ## Sprite class
  
  Game Item displaying an asset or a portion of it in a DOM element on the stage
  Can be a child of an Entity, in which case it will wrap it's element in the Entity's wrap element,
  otherwise will render inside its layer
  
  The rendering makes use of the SpriteRenderer class
  It also makes use of decorators, which are other overlapped sprites that can be switched on an
  off to create effects
  
  Initialise with a 'type' option, which will be the key of its preset in www/game/sprites.json
  
  Read Game Data class for more on JSON assets
  */


  Sprite = (function(_super) {

    __extends(Sprite, _super);

    Sprite.prototype.type = 'sprite';

    function Sprite(options, layer) {
      var _this = this;
      this.layer = layer;
      this.render = function() {
        return Sprite.prototype.render.apply(_this, arguments);
      };
      Sprite.__super__.constructor.apply(this, arguments);
      this.type = options.type;
      this.preset = gameData.get('sprites', this.type);
      this.entity = options.entity || null;
      this.viewport = this.layer.viewport;
      this.renderer = new SpriteRenderer(this.preset, this.viewport);
      this.decorators = {};
      this.flipped = {
        x: false,
        y: false
      };
      this.render();
      this.renderDecorators();
    }

    Sprite.prototype.renderDecorators = function() {
      var assetPath, decorator, el, key, _ref, _results;
      _ref = this.preset.decorators;
      _results = [];
      for (key in _ref) {
        decorator = _ref[key];
        el = $(renderer.render('game-decorator'));
        assetPath = assets.getAssetPath(decorator);
        el.css({
          backgroundImage: "url(" + assetPath + ")"
        });
        el.hide();
        this.el.append(el);
        _results.push(this.decorators[key] = el);
      }
      return _results;
    };

    Sprite.prototype.showDecorator = function(decoratorId) {
      return (this.getDecorator(decoratorId)).show();
    };

    Sprite.prototype.hideDecorator = function(decoratorId) {
      return (this.getDecorator(decoratorId)).hide();
    };

    Sprite.prototype.getDecorator = function(decoratorId) {
      return this.decorators[decoratorId];
    };

    Sprite.prototype.render = function() {
      this.renderer.render();
      this.el = this.renderer.el;
      this.updatePos();
      if (this.entity != null) {
        this.el.appendTo(this.entity.el);
        if (this.entity.hasAttr('wall-bg')) {
          this.el.css({
            backgroundColor: gameConfig.wallsColor
          });
        }
      } else {
        this.el.appendTo(this.layer.element);
      }
      if (this.entity != null) {
        this.el.data('entity', this.entity);
      }
      return this.el.data('sprite', this);
    };

    Sprite.prototype.moveTo = function() {
      Sprite.__super__.moveTo.apply(this, arguments);
      return this.updatePos();
    };

    Sprite.prototype.flip = function(dir) {
      var scaleX, scaleY;
      if (dir === 0) {
        this.flipped.x = !this.flipped.x;
      } else if (dir === 1) {
        this.flipped.y = !this.flipped.y;
      }
      scaleX = this.flipped.x ? -1 : 1;
      scaleY = this.flipped.y ? -1 : 1;
      return this.el.css({
        scale: "" + scaleX + ", " + scaleY
      });
    };

    Sprite.prototype.remove = function() {
      Sprite.__super__.remove.apply(this, arguments);
      return this.el.remove();
    };

    Sprite.prototype.getScreenPosition = function() {
      return this.viewport.worldToScreen({
        x: this.x,
        y: this.y
      });
    };

    Sprite.prototype.updatePos = function(x, y) {
      var h, pos, w;
      pos = this.getScreenPosition();
      w = this.viewport.worldToScreen(this.renderer.getPose().module[0]);
      h = this.viewport.worldToScreen(this.renderer.getPose().module[1]);
      return this.el.css({
        x: pos.x - w / 2,
        y: pos.y - h / 2
      });
    };

    return Sprite;

  })(BaseItem);

  module.exports = Sprite;

}).call(this);
