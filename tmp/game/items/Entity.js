// Generated by CoffeeScript 1.6.1
(function() {
  var BaseItem, Body, Entity, Sprite, behaviours, gameData, renderer,
    _this = this,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  renderer = require('../../core/renderer');

  BaseItem = require('./BaseItem');

  Sprite = require('./Sprite');

  Body = require('./Body');

  gameData = require('../utils/gameData');

  behaviours = require('../behaviours/index');

  /*
  ## Entity class
  
  Entities are the central players on the scene - They can have a body and multiple sprites which
  will move relatively to their position, they can be associated to a Behaviour, which will be
  manage their instance at every .update, they can have attributes which play a central role in
  the game mechanics.
  
  Entities can be instanciated with a preset from the ones contained in `www/game/presets.json`
  */


  Entity = (function(_super) {

    __extends(Entity, _super);

    Entity.prototype.itemType = 'entity';

    function Entity(options, layer) {
      var preset,
        _this = this;
      this.layer = layer;
      this.setPose = function(pose) {
        return Entity.prototype.setPose.apply(_this, arguments);
      };
      Entity.__super__.constructor.apply(this, arguments);
      if (options.preset) {
        preset = gameData.get('presets', options.preset);
        $.extend(true, options, preset);
      }
      this.attributes = options.attributes || {};
      this.id = options.id || null;
      this.data = options.data || {};
      this.behaviourType = options.behaviour || 'base';
      this.offset = {
        x: 0,
        y: 0
      };
      this.render();
      this.makeBody(options.bodies);
      this.sprites = [];
      this.makeSprites(options.sprites);
      this.updatePos();
    }

    Entity.prototype.initBehaviour = function() {
      return this.behaviour = new behaviours[this.behaviourType](this, this.layer.world);
    };

    Entity.prototype.render = function() {
      this.el = $(renderer.render('game-entity'));
      this.el.appendTo(this.layer.element);
      return this.el.data('entity', this);
    };

    Entity.prototype.makeSprites = function(sprites) {
      var options, sprite, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _results;
      for (_i = 0, _len = sprites.length; _i < _len; _i++) {
        sprite = sprites[_i];
        options = $.extend(true, {}, sprite, {
          entity: this
        });
        this.sprites.push(new Sprite(options, this.layer));
      }
      if ((this.hasAttr('flip-x')) && this.attributes['flip-x']) {
        _ref = this.sprites;
        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
          sprite = _ref[_j];
          sprite.flip(0);
        }
      }
      if ((this.hasAttr('flip-y')) && this.attributes['flip-y']) {
        _ref1 = this.sprites;
        _results = [];
        for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
          sprite = _ref1[_k];
          _results.push(sprite.flip(1));
        }
        return _results;
      }
    };

    Entity.prototype.hasAttr = function(attr) {
      return _.has(this.attributes, attr);
    };

    Entity.prototype.makeBody = function(bodies) {
      var body, i, options, _i, _len, _results;
      _results = [];
      for (i = _i = 0, _len = bodies.length; _i < _len; i = ++_i) {
        body = bodies[i];
        options = $.extend(true, {}, body);
        options.x = this.x + body.x;
        options.y = this.y + body.y;
        if (this.hasAttr('interaction')) {
          options.interaction = this.attributes.interaction;
        }
        if (this.hasAttr('material')) {
          options.mat = this.attributes.material;
        }
        if (i === 0) {
          this.offset = {
            x: body.x,
            y: body.y
          };
          this.body = new Body(options, this.layer.world);
          if (this.hasAttr('sensor')) {
            _results.push(this.body.setSensor(true));
          } else {
            _results.push(void 0);
          }
        } else {
          _results.push(this.body.addShape(options));
        }
      }
      return _results;
    };

    Entity.prototype.setPose = function(pose) {
      return this.sprite.pose = pose;
    };

    Entity.prototype.updatePos = function() {
      if (this.body != null) {
        return this.el.css(this.layer.viewport.worldToScreen(this.body.position()));
      }
    };

    Entity.prototype.distance = function(target, absolute) {
      var diff;
      if (absolute == null) {
        absolute = true;
      }
      diff = {
        x: this.x - target.x,
        y: this.x - target.y
      };
      if (absolute) {
        return Math.abs(diff);
      }
      return diff;
    };

    Entity.prototype.update = function() {
      return this.behaviour.update();
    };

    Entity.prototype.remove = function() {
      var sprite, _i, _len, _ref;
      Entity.__super__.remove.apply(this, arguments);
      this.el.remove();
      _ref = this.sprites;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        sprite = _ref[_i];
        sprite.remove();
      }
      if (this.body != null) {
        this.body.remove();
      }
      return this.removed = true;
    };

    Entity.prototype.position = function() {
      if (this.body != null) {
        return this.body.position();
      } else {
        return {
          x: this.x,
          y: this.y
        };
      }
    };

    Entity.prototype.onCollisionPre = function(target, callback) {
      return this.body.onCollision('pre', target.body, callback);
    };

    Entity.prototype.onCollisionPost = function(target, callback) {
      return this.body.onCollision('post', target.body, callback);
    };

    Entity.prototype.onCollisionStart = function(target, callback) {
      return this.body.onCollision('start', target.body, callback);
    };

    Entity.prototype.onCollisionEnd = function(target, callback) {
      return this.body.onCollision('end', target.body, callback);
    };

    return Entity;

  })(BaseItem);

  module.exports = Entity;

}).call(this);
