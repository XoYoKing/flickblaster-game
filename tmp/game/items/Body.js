// Generated by CoffeeScript 1.6.1
(function() {
  var BaseItem, Body, phys,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  phys = require('../utils/physics');

  BaseItem = require('./BaseItem');

  /*
  ## Body class
  
  This game item type interfaces the game logic with Box2D bodies
  Bodies can be added to the scene either stand-alone of as children of entities
  
  Currently supported types of Body are:
  1. **Circle**:      `circle` Initialise with `x`, `y` and `radius`
  2. **Rectangles**:  `rect` Initialise with `x`, `y`, `width` and `height`
  3. **Polygons**:    `poly` Initialise with `x`, `y` and a flat `points` array
  */


  Body = (function(_super) {

    __extends(Body, _super);

    Body.prototype.itemType = 'body';

    function Body(options, world) {
      var bodyData, i, _i, _ref;
      this.world = world;
      Body.__super__.constructor.apply(this, arguments);
      this.type = options.type;
      this.viewport = this.world.viewport;
      switch (this.type) {
        case 'circle':
          this.radius = options.radius;
          break;
        case 'rect':
          this.width = options.width;
          this.height = options.height;
          break;
        case 'poly':
          this.points = [];
          for (i = _i = 0, _ref = options.points.length / 2; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
            this.points.push([options.points[i * 2], options.points[i * 2 + 1]]);
          }
          break;
        default:
          return;
      }
      bodyData = phys.getBody(this.parseOptions(options));
      this.b2dBody = this.world.addBody(bodyData);
    }

    Body.prototype.parseOptions = function(options) {
      var out, point, x, y, _i, _len, _ref;
      out = {
        type: options.type,
        mat: options.mat || 'default',
        interaction: options.interaction || 'dynamic'
      };
      if ((options.x != null) && (options.y != null)) {
        out.x = this.viewport.worldToScreen(options.x);
        out.y = this.viewport.worldToScreen(options.y);
      }
      if (options.radius != null) {
        out.radius = this.viewport.worldToScreen(options.radius);
      }
      if ((options.width != null) && (options.height != null)) {
        out.width = this.viewport.worldToScreen(options.width);
        out.height = this.viewport.worldToScreen(options.height);
      }
      if (options.points != null) {
        out.points = [];
        _ref = this.points;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          point = _ref[_i];
          x = this.viewport.worldToScreen(point[0]);
          y = this.viewport.worldToScreen(point[1]);
          out.points.push([x, y]);
        }
      }
      return out;
    };

    Body.prototype.moveTo = function(pos) {
      var x, y,
        _this = this;
      x = (this.viewport.worldToScreen(pos.x)) / phys.ratio;
      y = (this.viewport.worldToScreen(pos.y)) / phys.ratio;
      pos = new phys.Vector(x, y);
      return setTimeout((function() {
        return _this.b2dBody.m_body.SetPosition(pos);
      }), .001);
    };

    Body.prototype.addShape = function(options) {
      var body, pos;
      options = this.parseOptions(options);
      body = phys.getBody(options);
      pos = this.viewport.worldToScreen(this.position());
      body.fixtureDef.shape.m_p.x = (options.x - pos.x) / phys.ratio;
      body.fixtureDef.shape.m_p.y = (options.y - pos.y) / phys.ratio;
      return this.b2dBody.m_body.CreateFixture(body.fixtureDef);
    };

    Body.prototype.applyForce = function(x, y, multiplier) {
      var point, vector;
      if (multiplier == null) {
        multiplier = 0;
      }
      point = this.b2dBody.m_body.GetWorldCenter();
      x = (this.viewport.worldToScreen(x)) * multiplier;
      y = (this.viewport.worldToScreen(y)) * multiplier;
      vector = phys.getVector(x, y);
      return this.b2dBody.m_body.ApplyForce(vector, point);
    };

    Body.prototype.position = function() {
      return this.viewport.screenToWorld(phys.getBodyPosition(this.b2dBody));
    };

    Body.prototype.setSensor = function(state) {
      return this.b2dBody.m_body.m_fixtureList.SetSensor(state);
    };

    Body.prototype.setDrag = function(amt) {
      return this.b2dBody.m_body.m_linearDamping = amt;
    };

    Body.prototype.remove = function() {
      if (this.entity != null) {
        this.entity.body = null;
      }
      return this.world.b2dWorld.DestroyBody(this.b2dBody.m_body);
    };

    Body.prototype.onCollision = function(evt, target, callback) {
      var _this = this;
      return this.world.collisionManager.on(evt, function(c) {
        var bodyA, bodyB, targetBody;
        bodyA = c.m_fixtureA.m_body;
        bodyB = c.m_fixtureB.m_body;
        if (target == null) {
          if (bodyA === _this.b2dBody.m_body) {
            callback(c);
          }
        } else {
          targetBody = target.b2dBody.m_body;
          if ((bodyA === targetBody && bodyB === _this.b2dBody.m_body) || (bodyA === _this.b2dBody.m_body && bodyB === targetBody)) {
            return callback(c);
          }
        }
      });
    };

    return Body;

  })(BaseItem);

  module.exports = Body;

}).call(this);
