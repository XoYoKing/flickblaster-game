// Generated by CoffeeScript 1.6.1
(function() {
  var GameControls, MouseControls, phys, renderer, shotStrength, style,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  shotStrength = 40;

  renderer = require('../../core/renderer');

  phys = require('../utils/physics');

  MouseControls = require('./MouseControls');

  style = {
    lineCap: 'round',
    strokeStyle: '#db7c52',
    lineWidth: 5
  };

  /*
  ## Game Controls Class
  
  Handles the binding, handling and UI of the game controls
  Read MouseControls for DOM bindings
  */


  GameControls = (function(_super) {

    __extends(GameControls, _super);

    function GameControls(game) {
      var _this = this;
      this.game = game;
      this.viewport = this.game.world.viewport;
      this.render();
      this.game.world.loop.use(function() {
        return _this.update();
      });
      GameControls.__super__.constructor.apply(this, arguments);
    }

    GameControls.prototype.render = function() {
      var ctx;
      ctx = {
        width: this.viewport.elWidth,
        height: this.viewport.elHeight
      };
      this.canvas = $(renderer.render('game-controls', ctx));
      this.canvas.hide().appendTo(this.game.world.stage);
      this.ctx = this.canvas[0].getContext('2d');
      return $.extend(this.ctx, style);
    };

    GameControls.prototype.update = function() {
      var center, vertex;
      this.clearLast();
      if (this.flicking) {
        center = this.viewport.worldToScreen(this.game.player.position());
        vertex = this.getRelativeMouse();
        this.ctx.beginPath();
        this.ctx.moveTo(center.x, center.y);
        this.ctx.lineTo(vertex.x, vertex.y);
        this.ctx.stroke();
        return this.lastUpdate = {
          x: center.x < vertex.x ? center.x : vertex.x,
          y: center.y < vertex.y ? center.y : vertex.y,
          width: Math.abs(center.x - vertex.x),
          height: Math.abs(center.y - vertex.y)
        };
      }
    };

    GameControls.prototype.clearLast = function() {
      var height, width, x, y;
      if (this.lastUpdate != null) {
        x = this.lastUpdate.x - style.lineWidth;
        y = this.lastUpdate.y - style.lineWidth;
        width = this.lastUpdate.width + style.lineWidth * 2;
        height = this.lastUpdate.height + style.lineWidth * 2;
        this.ctx.clearRect(x, y, width, height);
        return this.lastUpdate = null;
      }
    };

    GameControls.prototype.hideCanvas = function() {
      return this.canvas.hide();
    };

    GameControls.prototype.showCanvas = function() {
      return this.canvas.show();
    };

    GameControls.prototype.dragStart = function(e) {
      var entity, evt;
      GameControls.__super__.dragStart.apply(this, arguments);
      evt = this.getMouseEvent(e);
      entity = ($(evt.target)).data('entity');
      if ((entity != null) && entity.id === 'player') {
        this.showCanvas();
        this.flicking = true;
        return this.flickTarget = entity;
      }
    };

    GameControls.prototype.dragStop = function() {
      var center, dragged, vertex;
      GameControls.__super__.dragStop.apply(this, arguments);
      if (this.flicking) {
        (_(this.game.world)).emit('shoot', []);
        center = this.viewport.worldToScreen(this.game.player.position());
        vertex = this.getRelativeMouse();
        dragged = {
          x: center.x - vertex.x,
          y: center.y - vertex.y
        };
        this.hideCanvas();
        this.clearLast();
        this.flickTarget.body.applyForce(dragged.x, dragged.y, -shotStrength);
        this.flicking = false;
        return this.flickTarget = null;
      }
    };

    return GameControls;

  })(MouseControls);

  module.exports = GameControls;

}).call(this);
