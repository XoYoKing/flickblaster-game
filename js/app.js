;(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
/*
## App File

The main file that starts up the app

* Initialises the app and every module used in it
* Defines views routing
* Loads the Handlebars templates in the Renderer
* If the app is loaded through phonegap listens for `deviceready` Phonegap event
* Instanciates and open the first view
*/


(function() {
  var bind, device, gameData, init, onDeviceReady, renderer, touchables, views;

  device = require('./core/device');

  renderer = require('./core/renderer');

  views = require('./core/views');

  gameData = require('./game/utils/gameData');

  touchables = require('./ui/touchables');

  views.load({
    home: require('./views/HomeView'),
    levels: require('./views/LevelsView'),
    achievements: require('./views/AchievementsView'),
    game: require('./views/GameView')
  });

  views.init();

  renderer.templates = window.templates;

  init = function() {
    if (device.isTouch()) {
      return bind();
    } else {
      return onDeviceReady();
    }
  };

  bind = function() {
    return document.addEventListener('deviceready', onDeviceReady, false);
  };

  onDeviceReady = function() {};

  touchables.initialise();

  gameData.init();

  gameData.onReady(function() {
    return views.open('home');
  });

  init();

}).call(this);

},{"./core/device":4,"./core/renderer":5,"./core/views":7,"./game/utils/gameData":38,"./ui/touchables":47,"./views/AchievementsView":48,"./views/GameView":49,"./views/HomeView":50,"./views/LevelsView":51}],2:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
(function() {
  var BaseView, device, renderer, templatesRoot, win;

  renderer = require('./renderer');

  device = require('./device');

  win = $(window);

  templatesRoot = 'views/';

  /*
  ## Base View class
  
  Base class to extend from to create any view
  Takes care of basic rendering and defines main methods
  */


  BaseView = (function() {
    function BaseView() {}

    BaseView.prototype.templateName = '';

    BaseView.prototype.fixHeight = false;

    BaseView.prototype.classNames = '';

    BaseView.prototype.context = {};

    BaseView.prototype.render = function(wrapper) {
      var rendered,
        _this = this;
      rendered = renderer.render("" + templatesRoot + this.templateName, this.context);
      this.elements = {
        main: $("<div data-role='view' class='view " + this.classNames + "'>" + rendered + "</div>")
      };
      if (this.fixHeight) {
        this.elements.main.css({
          overflow: 'auto'
        });
      }
      this.getElements();
      if (wrapper != null) {
        this.elements.main.appendTo(wrapper);
      }
      this.resize();
      this.bind();
      win.on('resize', function() {
        return _this.resize();
      });
      return this;
    };

    BaseView.prototype.transitionComplete = function() {};

    BaseView.prototype.getElements = function() {};

    BaseView.prototype.bind = function() {
      var _this = this;
      this.resizeCallback = function() {
        return _this.resize();
      };
      return win.on('resize', this.resizeCallback);
    };

    BaseView.prototype.resize = function() {
      if (this.fixHeight) {
        return this.elements.main.css({
          height: device.getSize().height
        });
      }
    };

    BaseView.prototype.unbind = function() {};

    BaseView.prototype.close = function() {
      this.elements.main.remove();
      return win.off('resize', this.resizeCallback);
    };

    BaseView.prototype.hide = function() {
      return this.elements.main.hide();
    };

    BaseView.prototype.show = function() {
      this.elements.main.removeAttr('style');
      this.resize();
      return this.elements.main.show();
    };

    return BaseView;

  })();

  module.exports = BaseView;

}).call(this);

},{"./device":4,"./renderer":5}],3:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
/*
## Debug module

Defines debug settings - useful for debugging
*/


(function() {
  var helpers;

  helpers = require('../helpers/debug');

  module.exports = {
    skipAnimations: false,
    debugPhysics: false
  };

}).call(this);

},{"../helpers/debug":41}],4:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
/*
## Device module

* Provides information about the device and makes adjustments for testing if specified
* Maps all click events to equivalent touch events and provides them to UI modules
*/


(function() {
  var device, iOS, iOS7, isCordova, isMobile, isStandAlone, isTouch, onResize, testSizes, touchEvents, ua, useFakeSize, userAgent, win;

  win = $(window);

  testSizes = {
    'galaxy-s3': [720, 1280, 2],
    'galaxy-s4': [1080, 1920, 3],
    'nexus-4': [768, 1280, 2],
    'iphone-4': [640, 920, 2],
    'iphone-5': [640, 1136, 2],
    'ipad-mini': [768, 1024, 2]
  };

  touchEvents = {
    click: "tap",
    mousedown: "touchstart",
    mousemove: "touchmove",
    mouseup: "touchend"
  };

  userAgent = ua = navigator.userAgent;

  iOS = (ua.indexOf('iPhone')) !== -1 || (ua.indexOf('iPod')) !== -1 || (ua.indexOf('iPad')) !== -1;

  iOS7 = iOS && (ua.indexOf('OS 7')) !== -1;

  isStandAlone = window.navigator.standalone;

  isCordova = window.cordova;

  isMobile = window.navigator.userAgent.match(/(iPhone|iPod|iPad|Android|BlackBerry)/) ? true : false;

  isTouch = (_.has(document.documentElement, 'ontouchstart')) || (_.has(window, 'onmsgesturechange'));

  useFakeSize = (typeof fakeSize !== "undefined" && fakeSize !== null) && !isMobile;

  device = {
    isMobile: isMobile,
    size: null,
    isTouch: isTouch,
    pixelRatio: window.devicePixelRatio || 1,
    offset: {
      x: 0,
      y: 0
    }
  };

  onResize = function() {
    device.size = {
      width: win.width(),
      height: win.height()
    };
    if (iOS) {
      if (isCordova) {
        if (iOS7) {
          device.size.height -= 23;
          return device.offset.y += 23;
        }
      } else if (isStandAlone) {
        return device.size.height -= 10;
      } else if (iOS7) {
        ($(window)).css({
          overflow: 'hidden'
        });
        return device.size.height -= 105;
      } else {
        return device.size.height -= 60;
      }
    }
  };

  win.on('resize', onResize);

  onResize();

  module.exports = {
    resize: onResize,
    getPixelRatio: function() {
      return device.pixelRatio;
    },
    isTouch: function() {
      return device.isTouch;
    },
    isStandAlone: function() {
      return isStandAlone;
    },
    isFakeSize: function() {
      return typeof fakeSize !== "undefined" && fakeSize !== null;
    },
    getSize: function() {
      if (useFakeSize) {
        return {
          width: fakeSize[0] / fakeSize[2],
          height: fakeSize[1] / fakeSize[2]
        };
      }
      return device.size;
    },
    getOffset: function() {
      return device.offset || {
        x: 0,
        y: 0
      };
    },
    getEvent: function(evtType) {
      if (device.isTouch && (_.has(touchEvents, evtType))) {
        return touchEvents[evtType];
      } else {
        return evtType;
      }
    },
    getCenter: function() {
      return {
        x: device.size.width / 2,
        y: device.size.height / 2
      };
    }
  };

}).call(this);

},{}],5:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
/*
## Renderer module

Handles the storing and rendering of templates

The templates stored are Handlebars templates pre-compiled into functions
They are set in the main App file

Used to render all UI elements
*/


(function() {
  module.exports = {
    templates: {},
    compile: function(tpl) {
      if (typeof template === 'function') {
        return tpl;
      } else {
        return Handlebars.compile(tpl);
      }
    },
    set: function(id, template) {
      return this.templates[id] = typeof template === 'string' ? this.compile(template) : template;
    },
    get: function(nsString) {
      if (nsString == null) {
        nsString = null;
      }
      if (nsString != null) {
        return this.templates[nsString];
      } else {
        return this.templates;
      }
    },
    render: function(id, context) {
      return Handlebars.compile("{{> " + id + "}}")(context);
    }
  };

}).call(this);

},{}],6:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
/*
## View Transitions module

Contains core transitions between Views and DOM manipulation
*/


(function() {
  var debug, defaultDuration, device, flipViews, horizontalSlide, placeAbsolutely, popView, wrap;

  device = require('./device');

  debug = require('./debug');

  defaultDuration = debug.skipAnimations ? 0 : 400;

  wrap = $('#view-wrap');

  placeAbsolutely = function(view) {
    var deviceSize;
    deviceSize = device.getSize();
    return view.elements.main.css({
      position: 'absolute',
      top: 0,
      left: 0,
      width: deviceSize.width,
      height: deviceSize.height
    });
  };

  popView = function(scaleFrom, newView, oldView, callback, duration) {
    if (duration == null) {
      duration = defaultDuration;
    }
    placeAbsolutely(newView);
    newView.elements.main.css({
      scale: scaleFrom,
      opacity: 0,
      zIndex: 9999999
    });
    newView.elements.main.transition({
      scale: 1,
      opacity: 1
    });
    return setTimeout(function() {
      return callback(newView);
    }, defaultDuration);
  };

  horizontalSlide = function(dir, newView, oldView, callback, duration) {
    var deviceSize;
    if (duration == null) {
      duration = defaultDuration;
    }
    deviceSize = device.getSize();
    wrap.css({
      width: deviceSize.width,
      'overflow-x': 'hidden',
      position: 'relative'
    });
    placeAbsolutely(newView);
    newView.elements.main.css({
      x: (100 * dir) + '%'
    });
    newView.elements.main.transition({
      x: '0'
    }, duration);
    if (oldView != null) {
      oldView.elements.main.css({
        width: deviceSize.width,
        height: deviceSize.height
      });
      return oldView.elements.main.transition({
        x: (100 * -dir) + '%'
      }, duration, function() {
        return callback(newView);
      });
    }
  };

  flipViews = function(newView, oldView, callback) {
    var duration;
    duration = defaultDuration;
    placeAbsolutely(newView);
    oldView.elements.main.css({
      position: 'relative',
      'z-index': 1
    });
    newView.elements.main.css({
      'z-index': -1,
      rotateY: '-90deg',
      z: -500
    });
    oldView.elements.main.transition({
      rotateY: '90deg'
    }, duration / 2);
    return setTimeout(function() {
      return newView.elements.main.transition({
        rotateY: '0deg'
      }, duration / 2);
    }, duration / 2, function() {
      return callback(newView);
    });
  };

  module.exports = {
    'slide-right': function(newView, oldView, callback) {
      return horizontalSlide(1, newView, oldView, callback);
    },
    'slide-left': function(newView, oldView, callback) {
      return horizontalSlide(-1, newView, oldView, callback);
    },
    'flip': flipViews,
    'pop-out': function(newView, oldView, callback) {
      return popView(2.2, newView, oldView, callback);
    },
    'pop-in': function(newView, oldView, callback) {
      return popView(.7, newView, oldView, callback);
    },
    'fade-in': function(newView, oldView, callback) {
      newView.elements.main.hide();
      return newView.elements.main.fadeIn(defaultDuration, function() {
        return callback(newView);
      });
    }
  };

}).call(this);

},{"./debug":3,"./device":4}],7:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
/*
## Views module

Stores, instanciates, animates and handles views
*/


(function() {
  var device, getByRole, renderer, transitions, viewWrap, win;

  renderer = require('./renderer');

  device = require('./device');

  getByRole = (require('../helpers/dom')).getByRole;

  transitions = require('./viewTransitions');

  win = $(window);

  viewWrap = $('#view-wrap');

  module.exports = {
    wrap: $('#view-wrap'),
    current: null,
    shown: [],
    views: {},
    init: function() {
      var _this = this;
      viewWrap.css({
        overflow: 'hidden'
      });
      this.resize();
      this.bindFullscreen();
      return win.on('resize', function() {
        return _this.resize();
      });
    },
    bindFullscreen: function() {
      var _this = this;
      return window.addEventListener("load", function() {
        return setTimeout((function() {
          return device.resize();
        }), 0);
      });
    },
    resize: function() {
      var screen, x, y;
      screen = device.getSize();
      if (device.isFakeSize()) {
        x = (window.outerWidth - screen.width) / 2;
        y = (window.outerHeight - screen.height) / 2;
      } else {
        x = 0;
        y = 0;
      }
      return viewWrap.css({
        width: screen.width,
        height: screen.height,
        left: x + device.getOffset().x,
        top: y + device.getOffset().y
      });
    },
    closeAll: function() {
      return getByRole('view', this.wrap).remove();
    },
    load: function(ns, view) {
      var routes, _results;
      if (typeof ns === 'object') {
        routes = ns;
        _results = [];
        for (ns in routes) {
          view = routes[ns];
          _results.push(this.load(ns, view));
        }
        return _results;
      } else {
        return this.views[ns] = view;
      }
    },
    open: function(ns, transition, callback, openOnTop, options) {
      var view;
      if (transition == null) {
        transition = null;
      }
      if (callback == null) {
        callback = null;
      }
      if (openOnTop == null) {
        openOnTop = false;
      }
      if (options == null) {
        options = {};
      }
      if (!openOnTop) {
        this.shown = [];
      }
      if ((transition != null) && this.animating) {
        return false;
      }
      if (this.current != null) {
        this.current.unbind();
      }
      if (typeof ns === 'object') {
        view = ns;
      } else {
        view = new this.views[ns](options);
      }
      if (view.elements == null) {
        view.render(this.wrap);
      } else {
        view.show();
      }
      if ((transition != null) && _.has(this.transitions, transition)) {
        this.applyTransition(view, transition, callback, openOnTop);
      } else {
        this.onShown(view, callback, openOnTop);
      }
      return view;
    },
    applyTransition: function(view, transition, callback, openOnTop) {
      var newViewStyle, oldViewStyle, wrapStyle,
        _this = this;
      if (callback == null) {
        callback = null;
      }
      if (openOnTop == null) {
        openOnTop = false;
      }
      this.animating = true;
      oldViewStyle = this.current.elements.main.attr('style');
      newViewStyle = view.elements.main.attr('style');
      wrapStyle = this.wrap.attr('style');
      return this.transitions[transition](view, this.current, function() {
        _this.animating = false;
        _this.onShown(view, callback, openOnTop);
        _this.current.elements.main.stop();
        view.elements.main.stop();
        if (oldViewStyle) {
          _this.current.elements.main.attr('style', oldViewStyle);
        } else {
          _this.current.elements.main.removeAttr('style');
        }
        if (newViewStyle) {
          view.elements.main.attr('style', newViewStyle);
        } else {
          view.elements.main.removeAttr('style');
        }
        return _this.wrap.attr('style', wrapStyle);
      });
    },
    onShown: function(view, callback, openOnTop) {
      if (callback == null) {
        callback = null;
      }
      if (openOnTop == null) {
        openOnTop = false;
      }
      view.transitionComplete();
      if (!openOnTop) {
        if (this.current != null) {
          this.current.close();
        }
      } else {
        this.current.hide();
      }
      this.shown.push(view);
      this.current = view;
      if (callback != null) {
        return callback(view);
      }
    },
    transitions: transitions
  };

}).call(this);

},{"../helpers/dom":42,"./device":4,"./renderer":5,"./viewTransitions":6}],8:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
(function() {
  var CollisionManager, Lasers, Layer, Loop, Viewport, Walls, World, debug, debugHelpers, defaults, device, gameData, phys, renderer, templates;

  device = require('../core/device');

  renderer = require('../core/renderer');

  debug = require('../core/debug');

  debugHelpers = require('../helpers/debug');

  gameData = require('./utils/gameData');

  phys = require('./utils/physics');

  Layer = require('./components/Layer');

  Loop = require('./components/Loop');

  Viewport = require('./components/Viewport');

  Walls = require('./components/Walls');

  Lasers = require('./components/Lasers');

  CollisionManager = require('./components/CollisionManager');

  templates = {
    stage: 'partials/game-stage'
  };

  defaults = {
    gravity: [0, 0]
  };

  /*
  ## World class
  
  Ties together level data, physics, game loop, stage element, game layers and game items
  */


  World = (function() {
    function World(wrap, levelId, options) {
      var _this = this;
      this.wrap = wrap;
      if (options == null) {
        options = {};
      }
      this.ready = false;
      this.readyCallbacks = [];
      options = $.extend(true, {}, defaults, options);
      this.gravity = options.gravity;
      this.items = [];
      this.layers = {};
      this.stage = ($(renderer.render(templates.stage))).appendTo(this.wrap);
      this.loop = new Loop;
      this.started = false;
      this.initPhysics();
      this.loadLevel(levelId);
      this.onReady(function() {
        return _this.start();
      });
    }

    World.prototype.initPhysics = function() {
      var fps;
      fps = this.loop.getFPS();
      this.gravity = new phys.Vector(this.gravity[0], this.gravity[1]);
      this.b2dWorld = new phys.World(this.gravity, true);
      return this.collisionManager = new CollisionManager(this);
    };

    World.prototype.playPhysics = function() {
      var _this = this;
      return this.b2dInterval = window.setInterval(function() {
        _this.b2dWorld.Step(1 / 60, 10, 10);
        return _this.b2dWorld.ClearForces();
      }, 1000 / 60);
    };

    World.prototype.onReady = function(callback) {
      this.readyCallbacks.push(callback);
      if (this.ready) {
        return callback();
      }
    };

    World.prototype.loadLevel = function(levelId, callback) {
      var _this = this;
      return gameData.loadLevel(levelId, function(level) {
        var body, cb, entity, laser, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3, _results;
        _this.level = level;
        _this.viewport = new Viewport(_this.stage, _this.level.size[0], _this.level.size[1]);
        _this.addLayer('lasers', 'entity');
        _this.addLayer('entities', 'entity');
        _this.walls = new Walls(_this);
        _this.lasers = new Lasers(_this, _this.getLayerById('lasers'));
        _ref = (_this.loadLayerData('entities')).items;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          entity = _ref[_i];
          _this.addItem('entities', entity);
        }
        _ref1 = (_this.loadLayerData('walls')).items;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          body = _ref1[_j];
          _this.walls.add(body);
        }
        _this.walls.refresh();
        _ref2 = (_this.loadLayerData('lasers')).items;
        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
          laser = _ref2[_k];
          entity = _this.addItem('lasers', laser);
          entity.elements = _this.lasers.add(laser);
        }
        _this.lasers.refresh();
        _this.ready = true;
        _ref3 = _this.readyCallbacks;
        _results = [];
        for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
          cb = _ref3[_l];
          _results.push(cb());
        }
        return _results;
      });
    };

    World.prototype.addItem = function(layerId, item) {
      var layer;
      layer = this.getLayerById(layerId);
      item = layer.add(item);
      this.items.push(item);
      return item;
    };

    World.prototype.loadLayerData = function(layerId) {
      var layer, _i, _len, _ref;
      if (layerId != null) {
        _ref = this.level.layers;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          layer = _ref[_i];
          if (layer.id === layerId) {
            return layer;
          }
        }
      }
      return null;
    };

    World.prototype.addLayer = function(id, type) {
      return this.layers[id] = new Layer(this, type, id);
    };

    World.prototype.getLayerById = function(layerId) {
      if (this.layers[layerId]) {
        return this.layers[layerId];
      }
      return null;
    };

    World.prototype.addBody = function(body) {
      this.b2dWorld.Step();
      return this.b2dWorld.CreateBody(body.bodyDef).CreateFixture(body.fixtureDef);
    };

    World.prototype.getItemById = function(id) {
      var item, _i, _len, _ref;
      _ref = this.items;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        item = _ref[_i];
        if (item.id === id) {
          return item;
        }
      }
      return null;
    };

    World.prototype.getItemsByAttr = function(attr, value) {
      var item, matches, _i, _len, _ref;
      matches = [];
      _ref = this.items;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        item = _ref[_i];
        if (item.attributes != null) {
          if ((_.has(item.attributes, attr)) && item.attributes[attr] === value) {
            matches.push(item);
          }
        }
      }
      return matches;
    };

    World.prototype.start = function() {
      var _this = this;
      this.initBehaviours();
      this.loop.use(function() {
        return _this.update();
      });
      if (debug.debugPhysics) {
        return debugHelpers.initPhysicsDebugger(this);
      }
    };

    World.prototype.play = function() {
      this.playPhysics();
      return this.loop.play();
    };

    World.prototype.stop = function() {
      this.loop.pause();
      return clearInterval(this.b2dInterval);
    };

    World.prototype.initBehaviours = function() {
      var item, _i, _len, _ref;
      _ref = this.items;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        item = _ref[_i];
        if (item.itemType === 'entity') {
          item.initBehaviour();
        }
      }
      return this.started = true;
    };

    World.prototype.update = function() {
      var layer, layerId, _ref, _results;
      _ref = this.layers;
      _results = [];
      for (layerId in _ref) {
        layer = _ref[layerId];
        _results.push(layer.update());
      }
      return _results;
    };

    return World;

  })();

  module.exports = World;

}).call(this);

},{"../core/debug":3,"../core/device":4,"../core/renderer":5,"../helpers/debug":41,"./components/CollisionManager":21,"./components/Lasers":22,"./components/Layer":23,"./components/Loop":24,"./components/Viewport":25,"./components/Walls":26,"./utils/gameData":38,"./utils/physics":39}],9:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
(function() {
  var BaseActionableBehaviour, BaseBehaviour, actions,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  BaseBehaviour = require('./BaseBehaviour');

  actions = require('./actions');

  /*
  ## Base Actionable Behaviour class
  
  Base behaviour for buttons, sensors, teleports and all behaviours that react to activator collisions
  
  Calls .activate when touching the activator, it needs to be deactivated before running again
  */


  BaseActionableBehaviour = (function(_super) {
    __extends(BaseActionableBehaviour, _super);

    function BaseActionableBehaviour(entity, world) {
      var activator, activators, _i, _len,
        _this = this;
      this.entity = entity;
      this.world = world;
      BaseActionableBehaviour.__super__.constructor.apply(this, arguments);
      this.active = false;
      activators = this.world.getItemsByAttr('activator', true);
      for (_i = 0, _len = activators.length; _i < _len; _i++) {
        activator = activators[_i];
        this.addActivator(activator);
      }
      (_(this.world)).on('addActivator', function(activator) {
        return _this.addActivator(activator);
      });
    }

    BaseActionableBehaviour.prototype.addActivator = function(activator) {
      var _this = this;
      return this.entity.onCollisionStart(activator, function() {
        if (!_this.active) {
          return _this.activate(activator);
        }
      });
    };

    BaseActionableBehaviour.prototype.activate = function(activator) {
      if (this.active) {
        return;
      }
      if (this.entity.hasAttr('action')) {
        return actions.perform(this.entity.attributes.action, this);
      }
    };

    return BaseActionableBehaviour;

  })(BaseBehaviour);

  module.exports = BaseActionableBehaviour;

}).call(this);

},{"./BaseBehaviour":10,"./actions":19}],10:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
/*
## Base Behaviour class

This class is ment to be extended when creating a new Behaviour

Behaviours are instanciated as children of Entities and are passed their parent and their parent's
world, having so full access to manipulate the game logic

The parent Entity will call .update at every frame in the GameLoop
Read Entity for more
*/


(function() {
  var BaseBehaviour;

  BaseBehaviour = (function() {
    function BaseBehaviour(entity, world) {
      this.entity = entity;
      this.world = world;
    }

    BaseBehaviour.prototype.update = function() {
      var bodyPos, sprite, _i, _len, _ref;
      _ref = this.entity.sprites;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        sprite = _ref[_i];
        sprite.update();
      }
      if (this.entity.body != null) {
        this.entity.body.update();
        bodyPos = this.entity.body.position();
        if (this.entity.x !== bodyPos.x || this.entity.y !== bodyPos.y) {
          return this.entity.updatePos();
        }
      }
    };

    return BaseBehaviour;

  })();

  module.exports = BaseBehaviour;

}).call(this);

},{}],11:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
(function() {
  var BaseActionableBehaviour, ButtonBehaviour,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  BaseActionableBehaviour = require('./BaseActionableBehaviour');

  /*
  ## Button Behaviour class
  
  Buttons are an Actionable Behaviour that executes an action specified with an 'action' attribute
  on the Entity
  
  Read BaseActionableBehaviour and the Actions module for more
  */


  ButtonBehaviour = (function(_super) {
    __extends(ButtonBehaviour, _super);

    function ButtonBehaviour(entity, world) {
      this.entity = entity;
      this.world = world;
      ButtonBehaviour.__super__.constructor.apply(this, arguments);
      this.anchor = this.entity.attributes.anchor || 'left';
      this.sprite = this.entity.sprites[0];
      this.originalAttrs = {
        'background-position': this.sprite.el.css('background-position'),
        width: this.sprite.el.css('width'),
        height: this.sprite.el.css('height')
      };
    }

    ButtonBehaviour.prototype.activate = function(player) {
      var bgPos, css, height, width,
        _this = this;
      if (this.active) {
        return;
      }
      ButtonBehaviour.__super__.activate.apply(this, arguments);
      bgPos = (this.sprite.el.css('background-position')).split(' ');
      bgPos = {
        x: (bgPos[0].replace('px', '')) + 0,
        y: (bgPos[1].replace('px', '')) + 0
      };
      css = {};
      if (this.anchor === 'left' || this.anchor === 'right') {
        width = this.sprite.el.width();
        css.width = width / 2;
        css.backgroundPosition = "" + (bgPos.x - width / 2) + "px " + bgPos.y + "px";
        if (this.anchor === 'right') {
          css.left = width / 2;
        }
      }
      if (this.anchor === 'top' || this.anchor === 'bottom') {
        height = this.sprite.el.height();
        css.height = height / 2;
        css.backgroundPosition = "" + bgPos.x + "px -" + (bgPos.y - height / 2) + "px";
        if (this.anchor === 'bottom') {
          css.top = height / 2;
        }
      }
      this.sprite.el.stop().transition(css, 100, function() {
        if (_this.entity.attributes['multi-use']) {
          return _this.release();
        }
      });
      return this.active = true;
    };

    ButtonBehaviour.prototype.release = function() {
      var _this = this;
      return this.sprite.el.stop().transition(this.originalAttrs, 200, function() {
        return _this.active = false;
      });
    };

    ButtonBehaviour.prototype.update = function() {};

    return ButtonBehaviour;

  })(BaseActionableBehaviour);

  module.exports = ButtonBehaviour;

}).call(this);

},{"./BaseActionableBehaviour":9}],12:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
(function() {
  var BaseBehaviour, CannonBehaviour, defaultStrength, gameData,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  BaseBehaviour = require('./BaseBehaviour');

  gameData = require('../utils/gameData');

  defaultStrength = 2000;

  /*
  ## Cannon Behaviour class
  
  Cannons apply a force to their target when actioned
  */


  CannonBehaviour = (function(_super) {
    __extends(CannonBehaviour, _super);

    function CannonBehaviour(entity, world) {
      this.entity = entity;
      this.world = world;
      CannonBehaviour.__super__.constructor.apply(this, arguments);
      this.direction = this.entity.attributes.direction;
      this.spriteEl = this.entity.sprites[0].el;
    }

    CannonBehaviour.prototype.shoot = function() {
      var bullet, pos, targets,
        _this = this;
      pos = this.entity.position();
      bullet = {
        type: 'entity',
        preset: 'bullet',
        x: pos.x,
        y: pos.y
      };
      bullet = this.entity.layer.add(bullet);
      targets = this.world.getItemsByAttr('type', 'target');
      (_(this.world)).emit('addActivator', [bullet]);
      this.spriteEl.css({
        zoom: 1.2
      });
      this.spriteEl.stop().transition({
        zoom: 1
      }, 200);
      return setTimeout((function() {
        return bullet.body.applyForce(_this.direction[0], _this.direction[1], defaultStrength);
      }), 1);
    };

    return CannonBehaviour;

  })(BaseBehaviour);

  module.exports = CannonBehaviour;

}).call(this);

},{"../utils/gameData":38,"./BaseBehaviour":10}],13:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
(function() {
  var BaseBehaviour, LaserBehaviour, achievements,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  BaseBehaviour = require('./BaseBehaviour');

  achievements = require('../utils/achievements');

  /*
  ## Laser Behaviour class
  
  Determines the behaviour of laser Entities
  
  Laser Entities are Entities created through the editor with attributes `type` and `behaviour` set
  to `laser`
  Entities of 'type' attribute set to 'lasers' will be passe by the World instance to its Lasers
  manager and rendered with SVG
  */


  LaserBehaviour = (function(_super) {
    __extends(LaserBehaviour, _super);

    function LaserBehaviour(entity, world) {
      var _this = this;
      this.entity = entity;
      this.world = world;
      LaserBehaviour.__super__.constructor.apply(this, arguments);
      this.active = true;
      this.player = this.world.getItemById('player');
      this.touching = false;
      this.entity.body.setSensor(true);
      this.entity.onCollisionStart(this.player, function() {
        _this.touching = true;
        if (_this.active) {
          return _this.burnPlayer();
        }
      });
      this.entity.onCollisionEnd(this.player, function() {
        return _this.touching = false;
      });
      if ((this.entity.hasAttr('off')) && this.entity.attributes.off) {
        this.off();
      }
    }

    LaserBehaviour.prototype.burnPlayer = function() {
      var decorator, sprite,
        _this = this;
      sprite = this.player.sprites[0];
      decorator = sprite.getDecorator('burn');
      decorator.fadeIn(100);
      this.player.behaviour.die();
      this.checkAchievement();
      return sprite.el.fadeOut(300, function() {
        _this.player.remove();
        return (_(_this.player)).emit('die');
      });
    };

    LaserBehaviour.prototype.checkAchievement = function() {
      var timesBurned;
      timesBurned = (achievements.getData('times-burned')) || 0;
      timesBurned++;
      if (timesBurned === 10) {
        return achievements.unlock('fryup');
      } else {
        return achievements.storeData({
          'times-burned': timesBurned
        });
      }
    };

    LaserBehaviour.prototype.off = function() {
      var element, _i, _len, _ref;
      _ref = this.entity.elements;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        element = _ref[_i];
        element.remove();
        this.cachedElements = this.entity.elements;
      }
      this.world.lasers.refresh();
      return this.active = false;
    };

    LaserBehaviour.prototype.on = function() {
      var element, _i, _len, _ref;
      _ref = this.cachedElements;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        element = _ref[_i];
        this.world.lasers.el.append(element);
      }
      this.world.lasers.refresh();
      if (this.touching) {
        this.burnPlayer();
      }
      return this.active = true;
    };

    LaserBehaviour.prototype.toggle = function() {
      if (this.active) {
        return this.off();
      } else {
        return this.on();
      }
    };

    return LaserBehaviour;

  })(BaseBehaviour);

  module.exports = LaserBehaviour;

}).call(this);

},{"../utils/achievements":36,"./BaseBehaviour":10}],14:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
(function() {
  var BaseBehaviour, PlayerBehaviour,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  BaseBehaviour = require('./BaseBehaviour');

  /*
  ## Player Behaviour class
  
  Defines the behaviour of the player on stage
  Shamefully, the player is just that little red disc you flick around the stage when playing
  */


  PlayerBehaviour = (function(_super) {
    __extends(PlayerBehaviour, _super);

    function PlayerBehaviour(entity, world) {
      this.entity = entity;
      this.world = world;
      this.dead = false;
    }

    PlayerBehaviour.prototype.win = function(callback) {
      var sprite, _i, _len, _ref;
      _ref = this.entity.sprites;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        sprite = _ref[_i];
        sprite.el.transition({
          scale: .1,
          opacity: 0
        }, 600);
      }
      if (callback != null) {
        return setTimeout(callback, 600);
      }
    };

    PlayerBehaviour.prototype.die = function() {
      return this.dead = true;
    };

    return PlayerBehaviour;

  })(BaseBehaviour);

  module.exports = PlayerBehaviour;

}).call(this);

},{"./BaseBehaviour":10}],15:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
(function() {
  var BaseActionableBehaviour, SensorBehaviour,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  BaseActionableBehaviour = require('./BaseActionableBehaviour');

  /*
  ## Sensor Behaviours class
  
  Sensors execute an action specified through their 'action' attribute every time they're hovered by
  the player
  
  Read ActionableBehaviour for more
  */


  SensorBehaviour = (function(_super) {
    __extends(SensorBehaviour, _super);

    function SensorBehaviour(entity, world) {
      this.entity = entity;
      this.world = world;
      SensorBehaviour.__super__.constructor.apply(this, arguments);
      this.sprite = this.entity.sprites[0];
      this.light = this.sprite.decorators.light;
      (this.light.css({
        opacity: 0
      })).show();
    }

    SensorBehaviour.prototype.activate = function() {
      var _this = this;
      if (this.active) {
        return;
      }
      SensorBehaviour.__super__.activate.apply(this, arguments);
      return this.light.stop().transition({
        opacity: 1
      }, 50, function() {
        return _this.light.stop().transition({
          opacity: 0
        }, 500);
      });
    };

    return SensorBehaviour;

  })(BaseActionableBehaviour);

  module.exports = SensorBehaviour;

}).call(this);

},{"./BaseActionableBehaviour":9}],16:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
(function() {
  var BaseActionableBehaviour, TargetBehaviour,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  BaseActionableBehaviour = require('./BaseActionableBehaviour');

  /*
  ## Target Behaviour class
  
  Targets are the platforms player has to action to win the game
  
  On the same level there can theoretically be multiple targets and players
  Once a target gets hit by a player of another object with attribute `trigger-target` set to `true`,
  it will communicate the point to its World and stay in active state
  */


  TargetBehaviour = (function(_super) {
    __extends(TargetBehaviour, _super);

    function TargetBehaviour(entity, world) {
      this.entity = entity;
      this.world = world;
      TargetBehaviour.__super__.constructor.apply(this, arguments);
      this.lights = this.entity.sprites[0].getDecorator('lights');
      this.lights.show().css({
        opacity: 0
      });
    }

    TargetBehaviour.prototype.activate = function(activator) {
      var _this = this;
      TargetBehaviour.__super__.activate.apply(this, arguments);
      this.active = true;
      if (activator.behaviour.dead) {
        return;
      }
      this.lightsOn();
      this.pot();
      return this.entity.onCollisionEnd(activator, function() {
        if (!_this.potted) {
          return _this.lightsOff();
        }
      });
    };

    TargetBehaviour.prototype.pot = function() {
      this.potted = true;
      return (_(this.world)).emit('pot', [this]);
    };

    TargetBehaviour.prototype.lightsOn = function() {
      return this.lights.stop().transition({
        opacity: 1
      }, 500);
    };

    TargetBehaviour.prototype.lightsOff = function() {
      return this.lights.stop().transition({
        opacity: 0
      }, 500);
    };

    TargetBehaviour.prototype.update = function() {};

    return TargetBehaviour;

  })(BaseActionableBehaviour);

  module.exports = TargetBehaviour;

}).call(this);

},{"./BaseActionableBehaviour":9}],17:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
(function() {
  var BaseActionableBehaviour, TeleportBehaviour,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  BaseActionableBehaviour = require('./BaseActionableBehaviour');

  /*
  ## Teleport behaviour
  
  An actionable behaviour that teleports the player to the location of a second entity with 'id'
  matching its Entity 'target-id' attribute
  
  Read BaseActionableBehaviour and the Actions module for more
  */


  TeleportBehaviour = (function(_super) {
    __extends(TeleportBehaviour, _super);

    function TeleportBehaviour(entity, world) {
      this.entity = entity;
      this.world = world;
      TeleportBehaviour.__super__.constructor.apply(this, arguments);
      this.sprite = this.entity.sprites[0];
      this.lights = this.sprite.decorators.lights;
    }

    TeleportBehaviour.prototype.activate = function(player) {
      var playerSprite, target,
        _this = this;
      if (this.active || this.prevent) {
        return;
      }
      TeleportBehaviour.__super__.activate.apply(this, arguments);
      if (this.entity.hasAttr('target-id')) {
        target = this.world.getItemById(this.entity.attributes['target-id']);
      }
      playerSprite = player.sprites[0].el;
      if (target != null) {
        this.lightsFx();
        if (this.entity.attributes['single-use']) {
          this.pop();
        }
        if ((target.attributes.type != null) && target.attributes.type === 'teleport') {
          target.behaviour.lightsFx(200);
          if (target.attributes['single-use']) {
            target.behaviour.pop();
          }
        }
        return playerSprite.transition({
          opacity: 0
        }, 30, function() {
          player.body.moveTo(target.position());
          return playerSprite.transition({
            opacity: 1
          }, 30);
        });
      }
    };

    TeleportBehaviour.prototype.lightsFx = function(delay) {
      var _this = this;
      if (delay == null) {
        delay = 0;
      }
      this.active = true;
      return setTimeout((function() {
        return (_this.lights.css({
          opacity: 0,
          rotation: 0
        })).show().stop().transition({
          opacity: 1,
          rotate: 90
        }, 100, 'easeOutCirc', function() {
          _this.active = false;
          return _this.lights.stop().transition({
            opacity: 0,
            rotate: 180
          }, 200, 'easeInCirc');
        });
      }), delay);
    };

    TeleportBehaviour.prototype.pop = function() {
      var _this = this;
      this.prevent = true;
      return this.entity.el.stop().transition({
        scale: 1.3
      }, 200, function() {
        return _this.entity.el.stop().transition({
          scale: .1,
          opacity: 0
        }, 300, function() {
          return _this.entity.remove();
        });
      });
    };

    TeleportBehaviour.prototype.postUse = function() {};

    TeleportBehaviour.prototype.update = function() {};

    return TeleportBehaviour;

  })(BaseActionableBehaviour);

  module.exports = TeleportBehaviour;

}).call(this);

},{"./BaseActionableBehaviour":9}],18:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
(function() {
  var BaseActionableBehaviour, TurboBehaviour, defaultMultiplier,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  defaultMultiplier = 4;

  BaseActionableBehaviour = require('./BaseActionableBehaviour');

  /*
  ## Turbo Behaviours class
  
  Boosts player speed when hit
  
  Read ActionableBehaviour for more
  */


  TurboBehaviour = (function(_super) {
    __extends(TurboBehaviour, _super);

    function TurboBehaviour(entity, world) {
      this.entity = entity;
      this.world = world;
      TurboBehaviour.__super__.constructor.apply(this, arguments);
      this.multiplier = this.entity.attributes.multiplier || defaultMultiplier;
      this.sprite = this.entity.sprites[0];
      this.light = this.sprite.decorators.light;
      (this.light.css({
        opacity: 0
      })).show();
    }

    TurboBehaviour.prototype.activate = function(player) {
      var _this = this;
      if (this.active) {
        return;
      }
      TurboBehaviour.__super__.activate.apply(this, arguments);
      player.body.b2dBody.m_body.m_linearVelocity.x *= this.multiplier;
      player.body.b2dBody.m_body.m_linearVelocity.y *= this.multiplier;
      return this.light.stop().transition({
        opacity: 1
      }, 50, function() {
        return _this.light.stop().transition({
          opacity: 0
        }, 800);
      });
    };

    return TurboBehaviour;

  })(BaseActionableBehaviour);

  module.exports = TurboBehaviour;

}).call(this);

},{"./BaseActionableBehaviour":9}],19:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
/*
## Actions module

Actions are abstracted, common functions used by some behaviours

They are mapped to keys that match the 'action' attribute specified on Entities - mainly using
the editor, which some behaviours will parse and exectute passing the target Entity
*/


(function() {
  var actions, getEntityTargets;

  getEntityTargets = function(entity, world, type) {
    var targets;
    if (type == null) {
      type = null;
    }
    targets = [];
    if (entity.hasAttr('target-id')) {
      targets.push(world.getItemById(entity.attributes['target-id']));
    }
    if (entity.hasAttr('target-group')) {
      if (entity.attributes['target-group'] === 'all' && (type != null)) {
        targets = targets.concat(world.getItemsByAttr('type', type));
      } else {
        targets = targets.concat(world.getItemsByAttr('group', entity.attributes['target-group']));
      }
    }
    return targets;
  };

  actions = {
    'laser-toggle': function(entity, world, behaviour) {
      var target, targets, _i, _len, _results;
      targets = getEntityTargets(entity, world, 'laser');
      _results = [];
      for (_i = 0, _len = targets.length; _i < _len; _i++) {
        target = targets[_i];
        _results.push(target.behaviour.toggle());
      }
      return _results;
    },
    'laser-off': function(entity, world, behaviour) {
      var target, targets, _i, _len, _results;
      targets = getEntityTargets(entity, world, 'laser');
      _results = [];
      for (_i = 0, _len = targets.length; _i < _len; _i++) {
        target = targets[_i];
        _results.push(target.behaviour.off());
      }
      return _results;
    },
    'laser-on': function(entity, world, behaviour) {
      var target, targets, _i, _len, _results;
      targets = getEntityTargets(entity, world, 'laser');
      _results = [];
      for (_i = 0, _len = targets.length; _i < _len; _i++) {
        target = targets[_i];
        _results.push(target.behaviour.on());
      }
      return _results;
    },
    'cannon-shoot': function(entity, world, behaviour) {
      var cannon, targets, _i, _len, _results;
      targets = getEntityTargets(entity, world, 'cannon');
      _results = [];
      for (_i = 0, _len = targets.length; _i < _len; _i++) {
        cannon = targets[_i];
        _results.push(cannon.behaviour.shoot());
      }
      return _results;
    }
  };

  module.exports = {
    perform: function(action, target) {
      if (actions[action] != null) {
        return actions[action](target.entity, target.world, target);
      }
    }
  };

}).call(this);

},{}],20:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
/*
## Behaviours Index module

Routing map, assigns all behaviours to standardised keys so they match the behaviour specified
in Entities 'behaviour' attribute - usually through the editor

Read Entity to see how this module is used
*/


(function() {
  var base, button, cannon, laser, player, sensor, target, teleport, turbo;

  base = require('./BaseBehaviour');

  player = require('./PlayerBehaviour');

  target = require('./TargetBehaviour');

  laser = require('./LaserBehaviour');

  button = require('./ButtonBehaviour');

  teleport = require('./TeleportBehaviour');

  sensor = require('./SensorBehaviour');

  turbo = require('./TurboBehaviour');

  cannon = require('./CannonBehaviour');

  module.exports = {
    base: base,
    player: player,
    target: target,
    laser: laser,
    button: button,
    teleport: teleport,
    sensor: sensor,
    turbo: turbo,
    cannon: cannon
  };

}).call(this);

},{"./BaseBehaviour":10,"./ButtonBehaviour":11,"./CannonBehaviour":12,"./LaserBehaviour":13,"./PlayerBehaviour":14,"./SensorBehaviour":15,"./TargetBehaviour":16,"./TeleportBehaviour":17,"./TurboBehaviour":18}],21:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
(function() {
  var CollisionManager, phys;

  phys = require('../utils/physics');

  /*
  ## Collision Manager class
  
  Work around for major issues encountered with several different ways of
  binding events to Box2D collisions.
  
  The events you can bind are:
  1. `start`:         *Triggered before the collision is solved*
  2. `end`:           *Triggered after the collision is solved*
  3. `BeginContact`:  *Triggered before the contact has happened*
  4. `EndContact`:    *Triggered after the contact has happened*
  */


  CollisionManager = (function() {
    function CollisionManager(world) {
      this.world = world;
      this.callbacks = {
        start: [],
        end: [],
        pre: [],
        post: []
      };
      this.listener = new phys.ContactListener;
      this.bind();
    }

    CollisionManager.prototype.bind = function() {
      var _this = this;
      this.listener.BeginContact = function(contact) {
        var cb, _i, _len, _ref, _results;
        _ref = _this.callbacks.start;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          cb = _ref[_i];
          _results.push(cb(contact));
        }
        return _results;
      };
      this.listener.EndContact = function(contact) {
        var cb, _i, _len, _ref, _results;
        _ref = _this.callbacks.end;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          cb = _ref[_i];
          _results.push(cb(contact));
        }
        return _results;
      };
      this.listener.PreSolve = function(contact, impulse) {
        var cb, _i, _len, _ref, _results;
        _ref = _this.callbacks.pre;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          cb = _ref[_i];
          _results.push(cb(contact, impulse));
        }
        return _results;
      };
      this.listener.PostSolve = function(contact, oldManifold) {
        var cb, _i, _len, _ref, _results;
        _ref = _this.callbacks.post;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          cb = _ref[_i];
          _results.push(cb(contact, oldManifold));
        }
        return _results;
      };
      return this.world.b2dWorld.SetContactListener(this.listener);
    };

    CollisionManager.prototype.on = function(evt, callback) {
      return this.callbacks[evt].push(callback);
    };

    return CollisionManager;

  })();

  module.exports = CollisionManager;

}).call(this);

},{"../utils/physics":39}],22:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
(function() {
  var Lasers, colors, lasers, renderer, templates;

  renderer = require('../../core/renderer');

  colors = {
    yellow: '#f2c456',
    red: '#f56949',
    blue: '#5adef6'
  };

  templates = {
    lasers: 'partials/game-lasers',
    svg: {
      rect: 'partials/svg-rect'
    }
  };

  lasers = [];

  /*
  ## Lasers class
  
  Similar to Layer class, but handling lasers in the scene
  Renders the laser body using SVG, takes care of manipulating and updating it when needed
  */


  Lasers = (function() {
    function Lasers(world, layer) {
      this.world = world;
      this.layer = layer;
      this.viewport = this.world.viewport;
      this.width = this.viewport.width;
      this.height = this.viewport.height;
      this.render();
    }

    Lasers.prototype.render = function() {
      var ctx;
      ctx = {
        width: this.viewport.worldToScreen(this.width),
        height: this.viewport.worldToScreen(this.height)
      };
      return this.el = $(renderer.render(templates.lasers, ctx));
    };

    Lasers.prototype.add = function(entityOptions) {
      var body, ctx, el, height, out, width, x, y, _i, _len, _ref;
      out = [];
      _ref = entityOptions.bodies;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        body = _ref[_i];
        width = this.viewport.worldToScreen(body.width);
        height = this.viewport.worldToScreen(body.height);
        x = this.viewport.worldToScreen(body.x + entityOptions.x);
        y = this.viewport.worldToScreen(body.y + entityOptions.y);
        ctx = {
          x: x - width / 2,
          y: y - height / 2,
          width: width,
          height: height,
          fill: colors[entityOptions.attributes.color]
        };
        el = $(renderer.render(templates.svg.rect, ctx));
        this.el.append(el);
        out.push(el);
      }
      return out;
    };

    Lasers.prototype.refresh = function() {
      this.layer.element.html(' ');
      this.el.clone().appendTo(this.layer.element);
      return this.layer.element.html(this.layer.element.html());
    };

    return Lasers;

  })();

  module.exports = Lasers;

}).call(this);

},{"../../core/renderer":5}],23:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
(function() {
  var Entity, Layer, device, renderer, templates,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  renderer = require('../../core/renderer');

  device = require('../../core/device');

  Entity = require('../items/Entity');

  templates = {
    layer: 'partials/game-layer'
  };

  /*
  ## Layer class
  
  A layer contains and handles groups of Entities
  It also provides the items a separate DOM element to render within, so than the order of display of
  all items is manageable
  
  It also takes care of their updating
  */


  Layer = (function() {
    function Layer(world, itemsType, id) {
      this.world = world;
      this.itemsType = itemsType;
      this.id = id;
      this.update = __bind(this.update, this);
      this.add = __bind(this.add, this);
      this.viewport = this.world.viewport;
      this.element = $(renderer.render(templates.layer));
      this.element.appendTo(this.viewport.el);
      this.items = [];
    }

    Layer.prototype.add = function(options) {
      var item;
      if (this.itemsType === 'entity') {
        item = new Entity(options, this);
      } else {
        return;
      }
      if (this.world.started) {
        item.initBehaviour();
      }
      this.items.push(item);
      return item;
    };

    Layer.prototype.update = function() {
      var item, _i, _len, _ref, _results;
      _ref = this.items;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        item = _ref[_i];
        if (!item.removed) {
          _results.push(item.update());
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    return Layer;

  })();

  module.exports = Layer;

}).call(this);

},{"../../core/device":4,"../../core/renderer":5,"../items/Entity":32}],24:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
(function() {
  var Loop, requestAnimationFrame,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(callback) {
    return window.setTimeout(callback, 1000 / 60);
  };

  /*
  ## Loop class
  
  Based on a requestAnimationFrame polyfill, it handles the loop at the very core of the game
  Callbacks may be called at a different frequencies depending on device performance
  */


  Loop = (function() {
    function Loop() {
      this.getFPS = __bind(this.getFPS, this);
      this.next = __bind(this.next, this);
      this.use = __bind(this.use, this);
      this.pause = __bind(this.pause, this);
      this.play = __bind(this.play, this);
      this.callbacks = [];
      this.playing = false;
      this.fps = 0;
    }

    Loop.prototype.play = function() {
      this.playing = true;
      return requestAnimationFrame(this.next);
    };

    Loop.prototype.pause = function() {
      return this.playing = false;
    };

    Loop.prototype.use = function(callback) {
      return this.callbacks.push(callback);
    };

    Loop.prototype.next = function() {
      var callback, _i, _len, _ref;
      this.getFPS();
      _ref = this.callbacks;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        callback = _ref[_i];
        callback();
      }
      if (this.playing) {
        return requestAnimationFrame(this.next);
      }
    };

    Loop.prototype.getFPS = function() {
      var delta;
      if (!this.lastUpdate) {
        this.lastUpdate = new Date().getTime();
      }
      delta = (new Date().getTime() - this.lastCalledTime) / 1000;
      this.lastCalledTime = new Date().getTime();
      return this.fps = 1 / delta;
    };

    return Loop;

  })();

  module.exports = Loop;

}).call(this);

},{}],25:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
(function() {
  var Viewport, device, followEasing, topPadding, win;

  device = require('../../core/device');

  win = $(window);

  followEasing = 20;

  topPadding = 23;

  /*
  ## Viewport Class
  
  Contains game view elements on its wrapping elements, takes care of panning them into the screen
  after adapting to the screen size, it also takes care of translating screen coordinates into game
  coordinates and vice-versa
  
  This conversion is used by all modules that deal with rendering, and allows dealing with game
  logic, physics and measurement with better flexibility and ease
  */


  Viewport = (function() {
    function Viewport(el, width, height) {
      this.el = el;
      this.width = width;
      this.height = height;
      this.scaleRatio = 0;
      this.x = 0;
      this.y = 0;
      this.screen = device.getSize();
      this.fitInScreen();
      this.elWidth = this.el.width();
      this.elHeight = this.el.height();
      this.resize();
    }

    Viewport.prototype.resize = function() {
      this.screen = device.getSize();
      return this.center();
    };

    Viewport.prototype.center = function() {
      return this.moveTo((this.screen.width - this.elWidth) / 2, (this.screen.height - this.elHeight) / 2);
    };

    Viewport.prototype.fitInScreen = function() {
      this.scaleRatio = this.width / this.screen.width;
      if (this.height / this.scaleRatio + topPadding > this.screen.height) {
        this.scaleRatio = this.height / (this.screen.height - topPadding * 2);
      }
      return this.el.css({
        width: this.width / this.scaleRatio,
        height: this.height / this.scaleRatio
      });
    };

    Viewport.prototype.moveTo = function(x, y, duration, callback, ease) {
      var newX, newY,
        _this = this;
      if (duration == null) {
        duration = 0;
      }
      if (callback == null) {
        callback = null;
      }
      if (ease == null) {
        ease = false;
      }
      if (ease && !duration) {
        newX = this.x + (x - this.x) / followEasing;
        newY = this.y + (y - this.y) / followEasing;
        if ((Math.abs(this.x - newX)) < .1 && (Math.abs(this.y - newY)) < .1) {
          return;
        } else {
          this.x = newX;
          this.y = newY;
        }
      } else {
        if (this.x === x && this.y === y) {
          return;
        }
        this.x = x;
        this.y = y;
        y = this.y + topPadding / 2;
      }
      if (!duration) {
        this.el.css({
          x: this.x,
          y: y
        });
        if (callback != null) {
          return callback();
        }
      } else {
        return this.el.transition({
          x: this.x,
          y: y
        }, duration, function() {
          if (callback != null) {
            return callback();
          }
        });
      }
    };

    Viewport.prototype.worldToScreen = function(value) {
      if (typeof value === 'object' && (value.x != null) && (value.y != null)) {
        return {
          x: this.worldToScreen(value.x),
          y: this.worldToScreen(value.y)
        };
      } else {
        return value / this.scaleRatio;
      }
    };

    Viewport.prototype.screenToWorld = function(value) {
      if (typeof value === 'object' && (value.x != null) && (value.y != null)) {
        return {
          x: this.screenToWorld(value.x),
          y: this.screenToWorld(value.y)
        };
      } else {
        return value * this.scaleRatio;
      }
    };

    Viewport.prototype.fits = function() {
      return this.elHeight <= this.screen.height;
    };

    Viewport.prototype.followEntity = function(target, duration, callback) {
      var margin, targetPos, x, y;
      if (duration == null) {
        duration = 0;
      }
      if (callback == null) {
        callback = null;
      }
      targetPos = this.worldToScreen(target.position());
      x = -targetPos.x + this.screen.width / 2;
      y = -targetPos.y + this.screen.height / 2;
      if (this.elHeight >= this.screen.height) {
        margin = this.elHeight - this.screen.height;
        if (y > 0) {
          y = 0;
        } else if (y < -margin) {
          y = -margin;
        }
      }
      if (this.elWidth >= this.screen.width) {
        margin = this.elWidth - this.screen.width;
        if (x > 0) {
          x = 0;
        } else if (x < -margin) {
          x = -margin;
        }
      }
      return this.moveTo(x, y, duration, callback, true);
    };

    return Viewport;

  })();

  module.exports = Viewport;

}).call(this);

},{"../../core/device":4}],26:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
(function() {
  var Body, Wall, Walls, renderer, templates, thickness;

  renderer = require('../../core/renderer');

  Wall = require('../items/Wall');

  Body = require('../items/Body');

  thickness = 10;

  templates = {
    walls: 'partials/game-walls'
  };

  /*
  ## Walls Class
  
  Used as a child of World, handles the creation of the 4 Walls around the viewport and any other
  level-specific Wall passed from the World after loading the level data
  
  Also takes care of wrapping its children into an SVG object and refreshing its tree to display the
  updated render after the addition or change of any child Wall
  */


  Walls = (function() {
    function Walls(world) {
      this.world = world;
      this.width = this.world.viewport.width;
      this.height = this.world.viewport.height;
      this.walls = [];
      this.render();
      this.build();
      this.refresh();
    }

    Walls.prototype.render = function() {
      var ctx;
      ctx = {
        width: this.world.viewport.worldToScreen(this.width),
        height: this.world.viewport.worldToScreen(this.height)
      };
      this.wrap = $(renderer.render(templates.walls, ctx));
      this.svg = this.wrap.find('svg');
      return this.wrap.appendTo(this.world.stage);
    };

    Walls.prototype.refresh = function() {
      this.wrap.html(this.wrap.html());
      return this.svg = this.wrap.find('svg');
    };

    Walls.prototype.add = function(options) {
      return this.walls.push(new Wall(options, this.world, this.svg));
    };

    Walls.prototype.build = function() {
      var dir, h, opposite, w, x, y, _i, _len, _ref, _results;
      _ref = ['x', 'y'];
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        dir = _ref[_i];
        _results.push((function() {
          var _j, _len1, _ref1, _results1;
          _ref1 = [false, true];
          _results1 = [];
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            opposite = _ref1[_j];
            if (dir === 'x') {
              w = this.width;
              h = thickness;
              x = this.width / 2;
              y = opposite ? this.height : 0;
            } else {
              w = thickness;
              h = this.height;
              x = opposite ? this.width : 0;
              y = this.height / 2;
            }
            _results1.push(this.add({
              type: 'rect',
              x: x,
              y: y,
              width: w,
              height: h
            }));
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    return Walls;

  })();

  module.exports = Walls;

}).call(this);

},{"../../core/renderer":5,"../items/Body":31,"../items/Wall":34}],27:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
/*
## Game Configuration module

Exports a few setting used across game modules
*/


(function() {
  module.exports = {
    wallsColor: '#a2bfc9',
    gameDataPath: 'game-data'
  };

}).call(this);

},{}],28:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
(function() {
  var GameControls, MouseControls, phys, renderer, shotStrength, style, templates,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  shotStrength = 2.5;

  renderer = require('../../core/renderer');

  phys = require('../utils/physics');

  MouseControls = require('./MouseControls');

  style = {
    lineCap: 'round',
    strokeStyle: '#db7c52',
    lineWidth: 5
  };

  templates = {
    controls: 'partials/game-controls'
  };

  /*
  ## Game Controls Class
  
  Handles the binding, handling and UI of the game controls
  Read MouseControls for DOM bindings
  */


  GameControls = (function(_super) {
    __extends(GameControls, _super);

    function GameControls(game) {
      var _this = this;
      this.game = game;
      this.viewport = this.game.world.viewport;
      this.render();
      this.game.world.loop.use(function() {
        return _this.update();
      });
      GameControls.__super__.constructor.apply(this, arguments);
    }

    GameControls.prototype.render = function() {
      var ctx, lineWidth;
      ctx = {
        width: this.viewport.elWidth,
        height: this.viewport.elHeight
      };
      this.canvas = $(renderer.render(templates.controls, ctx));
      this.canvas.hide().appendTo(this.game.world.stage);
      this.ctx = this.canvas[0].getContext('2d');
      lineWidth = this.viewport.worldToScreen(style.lineWidth);
      $.extend(this.ctx, style);
      return this.ctx.lineWidth = lineWidth;
    };

    GameControls.prototype.update = function() {
      var center, vertex;
      this.clearLast();
      if (this.flicking) {
        center = this.viewport.worldToScreen(this.game.player.position());
        vertex = this.getRelativeMouse();
        this.ctx.beginPath();
        this.ctx.moveTo(center.x, center.y);
        this.ctx.lineTo(vertex.x, vertex.y);
        this.ctx.stroke();
        return this.lastUpdate = {
          x: center.x < vertex.x ? center.x : vertex.x,
          y: center.y < vertex.y ? center.y : vertex.y,
          width: Math.abs(center.x - vertex.x),
          height: Math.abs(center.y - vertex.y)
        };
      }
    };

    GameControls.prototype.clearLast = function() {
      var height, width, x, y;
      if (this.lastUpdate != null) {
        x = this.lastUpdate.x - this.ctx.lineWidth;
        y = this.lastUpdate.y - this.ctx.lineWidth;
        width = this.lastUpdate.width + this.ctx.lineWidth * 2;
        height = this.lastUpdate.height + this.ctx.lineWidth * 2;
        this.ctx.clearRect(x, y, width, height);
        return this.lastUpdate = null;
      }
    };

    GameControls.prototype.hideCanvas = function() {
      return this.canvas.hide();
    };

    GameControls.prototype.showCanvas = function() {
      return this.canvas.show();
    };

    GameControls.prototype.dragStart = function(e) {
      var entity, evt;
      GameControls.__super__.dragStart.apply(this, arguments);
      evt = this.getMouseEvent(e);
      entity = ($(evt.target)).data('entity');
      if ((entity != null) && entity.id === 'player') {
        this.showCanvas();
        this.flicking = true;
        return this.flickTarget = entity;
      }
    };

    GameControls.prototype.dragStop = function() {
      var center, dragged, vertex;
      GameControls.__super__.dragStop.apply(this, arguments);
      if (this.flicking) {
        (_(this.game.world)).emit('shoot', []);
        center = this.viewport.worldToScreen(this.game.player.position());
        vertex = this.getRelativeMouse();
        dragged = {
          x: center.x - vertex.x,
          y: center.y - vertex.y
        };
        dragged = this.viewport.screenToWorld(dragged);
        this.hideCanvas();
        this.clearLast();
        this.flickTarget.body.applyForce(-dragged.x, -dragged.y, shotStrength);
        this.flicking = false;
        return this.flickTarget = null;
      }
    };

    return GameControls;

  })(MouseControls);

  module.exports = GameControls;

}).call(this);

},{"../../core/renderer":5,"../utils/physics":39,"./MouseControls":29}],29:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
(function() {
  var MouseControls, body, device, viewWrap;

  device = require('../../core/device');

  body = $('body');

  viewWrap = $('#view-wrap');

  /*
  ## Mouse Controls class
  
  Utility class to quickly bind mouse controls setups
  Extend and have access to mouse position and cached mouse events at anytime
  */


  MouseControls = (function() {
    function MouseControls(game) {
      this.game = game;
      this.wrap = this.game.world.stage;
      this.offset = viewWrap.offset();
      this.active = false;
      this.mouse = {
        x: null,
        y: null,
        down: false,
        dragging: false
      };
      this.clickStart = null;
      this.lastDrag = null;
      this.dragOffset = null;
      this.preventClick = false;
    }

    MouseControls.prototype.on = function() {
      this.active = true;
      return this.bind();
    };

    MouseControls.prototype.off = function() {
      this.active = false;
      return this.reset();
    };

    MouseControls.prototype.reset = function() {
      this.wrap.off(device.getEvent('mousemove'));
      this.wrap.off(device.getEvent('mousedown'));
      this.wrap.off(device.getEvent('mouseup'));
      return this.wrap.off(device.getEvent('tap'));
    };

    MouseControls.prototype.bind = function() {
      var self,
        _this = this;
      self = this;
      this.wrap.on(device.getEvent('mousemove'), function(e) {
        if (_this.active) {
          return _this.mouseMove(e);
        }
      });
      this.wrap.on(device.getEvent('mousedown'), function(e) {
        if (_this.active) {
          return _this.mouseDown(e);
        }
      });
      this.wrap.on(device.getEvent('mouseup'), function(e) {
        if (_this.active) {
          return _this.mouseUp(e);
        }
      });
      return this.wrap.on(device.getEvent('tap'), function(e) {
        if (_this.active && !_this.preventClick) {
          return _this.click($(e.target), e);
        }
      });
    };

    MouseControls.prototype.updateMousePosition = function(e) {
      var moved;
      moved = this.getMouseEvent(e);
      this.mouse.x = moved.pageX;
      return this.mouse.y = moved.pageY;
    };

    MouseControls.prototype.mouseDown = function(e) {
      this.preventClick = false;
      this.updateMousePosition(e);
      this.clickStart = {
        x: this.mouse.x,
        y: this.mouse.y
      };
      return this.mouse.down = true;
    };

    MouseControls.prototype.mouseMove = function(e) {
      var moved;
      if (this.mouse.dragging) {
        this.dragOffset = this.getDragOffset();
        this.lastDrag = {
          x: this.mouse.x,
          y: this.mouse.y
        };
        this.dragMove(this.dragOffset.last, this.dragOffset.total, e);
      } else if ((this.clickStart != null) && this.mouse.down) {
        moved = (Math.abs(this.clickStart.x - this.mouse.x)) + (Math.abs(this.clickStart.y - this.mouse.y));
        if (moved > 1) {
          this.lastDrag = this.clickStart;
          this.mouse.dragging = true;
          this.dragStart(e);
        }
      }
      return this.updateMousePosition(e);
    };

    MouseControls.prototype.mouseUp = function(e) {
      var dragOffset;
      if (this.mouse.dragging) {
        dragOffset = this.getDragOffset();
        this.mouse.dragging = false;
        this.dragStop(dragOffset.last, dragOffset.total, e);
      }
      return this.mouse.down = false;
    };

    MouseControls.prototype.click = function(target, e) {};

    MouseControls.prototype.getDragOffset = function() {
      var last, total;
      if (!this.mouse.dragging) {
        return null;
      }
      last = {
        x: this.mouse.x - this.lastDrag.x,
        y: this.mouse.y - this.lastDrag.y
      };
      total = {
        x: this.lastDrag.x - this.clickStart.x,
        y: this.lastDrag.y - this.clickStart.y
      };
      return {
        last: last,
        total: total
      };
    };

    MouseControls.prototype.dragStart = function(e) {
      return this.preventClick = true;
    };

    MouseControls.prototype.dragMove = function(lastOffset, totalOffset, e) {};

    MouseControls.prototype.dragStop = function(e) {};

    MouseControls.prototype.getRelativeMouse = function() {
      var pos, screen;
      screen = device.getSize();
      pos = {
        x: this.mouse.x - this.offset.left - this.viewport.x,
        y: this.mouse.y - this.offset.top - this.viewport.y
      };
      return pos;
    };

    MouseControls.prototype.getMouseEvent = function(e) {
      if ((_.has(e, 'pageX')) && (_.has(e, 'pageY'))) {
        return e;
      } else if (_.has(e.originalEvent, 'touches')) {
        return e.originalEvent.touches[0];
      } else {
        return {
          pageX: 0,
          pageY: 0,
          target: null
        };
      }
    };

    return MouseControls;

  })();

  module.exports = MouseControls;

}).call(this);

},{"../../core/device":4}],30:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
(function() {
  var BaseItem, defaults;

  defaults = {
    x: 0,
    y: 0
  };

  /*
  ## Base Item class
  
  Item classes that interact with the game logic have to extend from here
  
  E.g. Entities, Bodies, Sprites and Walls extend from BaseItem
  
  The World and Layer classes will need to always have acces to the basic
  method specified in this class
  */


  BaseItem = (function() {
    BaseItem.prototype.itemType = 'base';

    function BaseItem(options, layer) {
      this.layer = layer;
      options = $.extend(true, {}, defaults, options);
      this.x = options.x || 0;
      this.y = options.y || 0;
      this.removed = false;
    }

    BaseItem.prototype.translate = function(x, y) {
      return this.moveTo(this.x + x, this.y + y);
    };

    BaseItem.prototype.moveTo = function(x, y) {
      this.x = x;
      return this.y = y;
    };

    BaseItem.prototype.update = function() {};

    BaseItem.prototype.remove = function() {};

    return BaseItem;

  })();

  module.exports = BaseItem;

}).call(this);

},{}],31:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
(function() {
  var BaseItem, Body, phys,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  phys = require('../utils/physics');

  BaseItem = require('./BaseItem');

  /*
  ## Body class
  
  This game item type interfaces the game logic with Box2D bodies
  Bodies can be added to the scene either stand-alone of as children of entities
  
  Currently supported types of Body are:
  1. **Circle**:      `circle` Initialise with `x`, `y` and `radius`
  2. **Rectangles**:  `rect` Initialise with `x`, `y`, `width` and `height`
  3. **Polygons**:    `poly` Initialise with `x`, `y` and a flat `points` array
  */


  Body = (function(_super) {
    __extends(Body, _super);

    Body.prototype.itemType = 'body';

    function Body(options, world) {
      var bodyData, i, _i, _ref;
      this.world = world;
      Body.__super__.constructor.apply(this, arguments);
      this.type = options.type;
      this.viewport = this.world.viewport;
      switch (this.type) {
        case 'circle':
          this.radius = options.radius;
          break;
        case 'rect':
          this.width = options.width;
          this.height = options.height;
          break;
        case 'poly':
          this.points = [];
          for (i = _i = 0, _ref = options.points.length / 2; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
            this.points.push([options.points[i * 2], options.points[i * 2 + 1]]);
          }
          break;
        default:
          return;
      }
      bodyData = phys.getBody(this.parseOptions(options));
      this.b2dBody = this.world.addBody(bodyData);
    }

    Body.prototype.parseOptions = function(options) {
      var i, out, x, y, _i, _ref;
      out = $.extend(true, {}, options);
      if (options.points != null) {
        out.points = [];
        for (i = _i = 0, _ref = options.points.length / 2; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          x = options.points[i * 2];
          y = options.points[i * 2 + 1];
          out.points.push([x, y]);
        }
      }
      return out;
    };

    Body.prototype.moveTo = function(pos) {
      var x, y,
        _this = this;
      x = pos.x / phys.ratio;
      y = pos.y / phys.ratio;
      pos = new phys.Vector(x, y);
      return setTimeout((function() {
        return _this.b2dBody.m_body.SetPosition(pos);
      }), .001);
    };

    Body.prototype.addShape = function(options) {
      var body, pos, v, _i, _len, _ref;
      options = this.parseOptions(options);
      body = phys.getBody(options);
      pos = this.position();
      _ref = body.fixtureDef.shape.m_vertices;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        v = _ref[_i];
        v.x += (options.x - pos.x) / 30;
        v.y += (options.y - pos.y) / 30;
      }
      return this.b2dBody.m_body.CreateFixture(body.fixtureDef);
    };

    Body.prototype.applyForce = function(x, y, multiplier) {
      var point, vector;
      if (multiplier == null) {
        multiplier = 0;
      }
      point = this.b2dBody.m_body.GetWorldCenter();
      x *= multiplier;
      y *= multiplier;
      vector = phys.getVector(x, y);
      return this.b2dBody.m_body.ApplyForce(vector, point);
    };

    Body.prototype.position = function() {
      return phys.getBodyPosition(this.b2dBody);
    };

    Body.prototype.setSensor = function(state) {
      return this.b2dBody.m_body.m_fixtureList.SetSensor(state);
    };

    Body.prototype.setDrag = function(amt) {
      return this.b2dBody.m_body.m_linearDamping = amt;
    };

    Body.prototype.remove = function() {
      if (this.entity != null) {
        this.entity.body = null;
      }
      return this.world.b2dWorld.DestroyBody(this.b2dBody.m_body);
    };

    Body.prototype.onCollision = function(evt, target, callback) {
      var _this = this;
      return this.world.collisionManager.on(evt, function(c) {
        var bodyA, bodyB, targetBody;
        bodyA = c.m_fixtureA.m_body;
        bodyB = c.m_fixtureB.m_body;
        if (target == null) {
          if (bodyA === _this.b2dBody.m_body) {
            callback(c);
          }
        } else {
          targetBody = target.b2dBody.m_body;
          if ((bodyA === targetBody && bodyB === _this.b2dBody.m_body) || (bodyA === _this.b2dBody.m_body && bodyB === targetBody)) {
            return callback(c);
          }
        }
      });
    };

    return Body;

  })(BaseItem);

  module.exports = Body;

}).call(this);

},{"../utils/physics":39,"./BaseItem":30}],32:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
(function() {
  var BaseItem, Body, Entity, Sprite, behaviours, gameData, renderer, templates,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  renderer = require('../../core/renderer');

  BaseItem = require('./BaseItem');

  Sprite = require('./Sprite');

  Body = require('./Body');

  gameData = require('../utils/gameData');

  behaviours = require('../behaviours/index');

  templates = {
    entity: 'partials/game-entity'
  };

  /*
  ## Entity class
  
  Entities are the central players on the scene - They can have a body and multiple sprites which
  will move relatively to their position, they can be associated to a Behaviour, which will be
  manage their instance at every .update, they can have attributes which play a central role in
  the game mechanics.
  
  Entities can be instanciated with a preset from the ones contained in `www/game/presets.json`
  */


  Entity = (function(_super) {
    __extends(Entity, _super);

    Entity.prototype.itemType = 'entity';

    function Entity(options, layer) {
      var preset;
      this.layer = layer;
      this.setPose = __bind(this.setPose, this);
      Entity.__super__.constructor.apply(this, arguments);
      if (options.preset) {
        preset = gameData.get('presets', options.preset);
        $.extend(true, options, preset);
      }
      this.attributes = options.attributes || {};
      this.id = options.id || null;
      this.data = options.data || {};
      this.behaviourType = options.behaviour || 'base';
      this.offset = {
        x: 0,
        y: 0
      };
      this.render();
      this.makeBody(options.bodies);
      this.sprites = [];
      this.makeSprites(options.sprites);
      this.updatePos();
    }

    Entity.prototype.initBehaviour = function() {
      return this.behaviour = new behaviours[this.behaviourType](this, this.layer.world);
    };

    Entity.prototype.render = function() {
      this.el = $(renderer.render(templates.entity));
      this.el.appendTo(this.layer.element);
      this.el.data('entity', this);
      if (this.hasAttr('z-index')) {
        return this.el.css({
          zIndex: this.attributes['z-index']
        });
      }
    };

    Entity.prototype.makeSprites = function(sprites) {
      var options, sprite, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _results;
      for (_i = 0, _len = sprites.length; _i < _len; _i++) {
        sprite = sprites[_i];
        options = $.extend(true, {}, sprite, {
          entity: this
        });
        this.sprites.push(new Sprite(options, this.layer));
      }
      if ((this.hasAttr('flip-x')) && this.attributes['flip-x']) {
        _ref = this.sprites;
        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
          sprite = _ref[_j];
          sprite.flip(0);
        }
      }
      if ((this.hasAttr('flip-y')) && this.attributes['flip-y']) {
        _ref1 = this.sprites;
        _results = [];
        for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
          sprite = _ref1[_k];
          _results.push(sprite.flip(1));
        }
        return _results;
      }
    };

    Entity.prototype.hasAttr = function(attr) {
      return _.has(this.attributes, attr);
    };

    Entity.prototype.makeBody = function(bodies) {
      var body, i, options, _i, _len, _results;
      _results = [];
      for (i = _i = 0, _len = bodies.length; _i < _len; i = ++_i) {
        body = bodies[i];
        options = $.extend(true, {}, body);
        options.x = this.x + body.x;
        options.y = this.y + body.y;
        if (this.hasAttr('interaction')) {
          options.interaction = this.attributes.interaction;
        }
        if (this.hasAttr('material')) {
          options.mat = this.attributes.material;
        }
        if (i === 0) {
          this.bodyOffset = {
            x: body.x,
            y: body.y
          };
          this.offset = {
            x: body.x,
            y: body.y
          };
          this.body = new Body(options, this.layer.world);
          if (this.hasAttr('sensor')) {
            _results.push(this.body.setSensor(true));
          } else {
            _results.push(void 0);
          }
        } else {
          _results.push(this.body.addShape(options));
        }
      }
      return _results;
    };

    Entity.prototype.setPose = function(pose) {
      return this.sprite.pose = pose;
    };

    Entity.prototype.updatePos = function() {
      var pos;
      if (this.body != null) {
        pos = this.layer.viewport.worldToScreen(this.body.position());
        pos.x -= this.layer.viewport.worldToScreen(this.bodyOffset.x);
        pos.y -= this.layer.viewport.worldToScreen(this.bodyOffset.y);
        return this.el.css(pos);
      }
    };

    Entity.prototype.distance = function(target, absolute) {
      var diff;
      if (absolute == null) {
        absolute = true;
      }
      diff = {
        x: this.x - target.x,
        y: this.x - target.y
      };
      if (absolute) {
        return Math.abs(diff);
      }
      return diff;
    };

    Entity.prototype.update = function() {
      return this.behaviour.update();
    };

    Entity.prototype.remove = function() {
      var sprite, _i, _len, _ref;
      Entity.__super__.remove.apply(this, arguments);
      this.el.remove();
      _ref = this.sprites;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        sprite = _ref[_i];
        sprite.remove();
      }
      if (this.body != null) {
        this.body.remove();
      }
      return this.removed = true;
    };

    Entity.prototype.position = function() {
      var pos;
      if (this.body != null) {
        pos = this.body.position();
        return {
          x: pos.x - this.bodyOffset.x,
          y: pos.y - this.bodyOffset.y
        };
      } else {
        return {
          x: this.x,
          y: this.y
        };
      }
    };

    Entity.prototype.onCollisionPre = function(target, callback) {
      return this.body.onCollision('pre', target.body, callback);
    };

    Entity.prototype.onCollisionPost = function(target, callback) {
      return this.body.onCollision('post', target.body, callback);
    };

    Entity.prototype.onCollisionStart = function(target, callback) {
      return this.body.onCollision('start', target.body, callback);
    };

    Entity.prototype.onCollisionEnd = function(target, callback) {
      return this.body.onCollision('end', target.body, callback);
    };

    return Entity;

  })(BaseItem);

  module.exports = Entity;

}).call(this);

},{"../../core/renderer":5,"../behaviours/index":20,"../utils/gameData":38,"./BaseItem":30,"./Body":31,"./Sprite":33}],33:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
(function() {
  var BaseItem, Sprite, SpriteRenderer, assets, gameConfig, gameData, renderer, templates,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  renderer = require('../../core/renderer');

  BaseItem = require('./BaseItem');

  SpriteRenderer = require('../utils/SpriteRenderer');

  gameData = require('../utils/gameData');

  assets = require('../utils/assets');

  gameConfig = require('../config');

  templates = {
    decorator: 'partials/game-decorator'
  };

  /*
  ## Sprite class
  
  Game Item displaying an asset or a portion of it in a DOM element on the stage
  Can be a child of an Entity, in which case it will wrap it's element in the Entity's wrap element,
  otherwise will render inside its layer
  
  The rendering makes use of the SpriteRenderer class
  It also makes use of decorators, which are other overlapped sprites that can be switched on an
  off to create effects
  
  Initialise with a 'type' option, which will be the key of its preset in www/game/sprites.json
  
  Read Game Data class for more on JSON assets
  */


  Sprite = (function(_super) {
    __extends(Sprite, _super);

    Sprite.prototype.type = 'sprite';

    function Sprite(options, layer) {
      this.layer = layer;
      this.render = __bind(this.render, this);
      Sprite.__super__.constructor.apply(this, arguments);
      this.type = options.type;
      this.preset = gameData.get('sprites', this.type);
      this.entity = options.entity || null;
      this.viewport = this.layer.viewport;
      this.renderer = new SpriteRenderer(this.preset, this.viewport);
      this.decorators = {};
      this.flipped = {
        x: false,
        y: false
      };
      this.render();
      this.renderDecorators();
    }

    Sprite.prototype.renderDecorators = function() {
      var assetPath, decorator, el, key, _ref, _results;
      _ref = this.preset.decorators;
      _results = [];
      for (key in _ref) {
        decorator = _ref[key];
        el = $(renderer.render(templates.decorator));
        assetPath = assets.getAssetPath(decorator);
        el.css({
          backgroundImage: "url(" + assetPath + ")"
        });
        el.hide();
        this.el.append(el);
        _results.push(this.decorators[key] = el);
      }
      return _results;
    };

    Sprite.prototype.showDecorator = function(decoratorId) {
      return (this.getDecorator(decoratorId)).show();
    };

    Sprite.prototype.hideDecorator = function(decoratorId) {
      return (this.getDecorator(decoratorId)).hide();
    };

    Sprite.prototype.getDecorator = function(decoratorId) {
      return this.decorators[decoratorId];
    };

    Sprite.prototype.render = function() {
      this.renderer.render();
      this.el = this.renderer.el;
      this.updatePos();
      if (this.entity != null) {
        this.el.appendTo(this.entity.el);
        if (this.entity.hasAttr('wall-bg')) {
          this.el.css({
            backgroundColor: gameConfig.wallsColor
          });
        }
      } else {
        this.el.appendTo(this.layer.element);
      }
      if (this.entity != null) {
        this.el.data('entity', this.entity);
      }
      return this.el.data('sprite', this);
    };

    Sprite.prototype.moveTo = function() {
      Sprite.__super__.moveTo.apply(this, arguments);
      return this.updatePos();
    };

    Sprite.prototype.flip = function(dir) {
      var scaleX, scaleY;
      if (dir === 0) {
        this.flipped.x = !this.flipped.x;
      } else if (dir === 1) {
        this.flipped.y = !this.flipped.y;
      }
      scaleX = this.flipped.x ? -1 : 1;
      scaleY = this.flipped.y ? -1 : 1;
      return this.el.css({
        scale: "" + scaleX + ", " + scaleY
      });
    };

    Sprite.prototype.remove = function() {
      Sprite.__super__.remove.apply(this, arguments);
      return this.el.remove();
    };

    Sprite.prototype.getScreenPosition = function() {
      return this.viewport.worldToScreen({
        x: this.x,
        y: this.y
      });
    };

    Sprite.prototype.updatePos = function(x, y) {
      var h, pos, w;
      pos = this.getScreenPosition();
      w = this.viewport.worldToScreen(this.renderer.getPose().module[0]);
      h = this.viewport.worldToScreen(this.renderer.getPose().module[1]);
      return this.el.css({
        x: pos.x - w / 2,
        y: pos.y - h / 2
      });
    };

    return Sprite;

  })(BaseItem);

  module.exports = Sprite;

}).call(this);

},{"../../core/renderer":5,"../config":27,"../utils/SpriteRenderer":35,"../utils/assets":37,"../utils/gameData":38,"./BaseItem":30}],34:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
(function() {
  var Body, Wall, gameConfig, renderer, templates,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  renderer = require('../../core/renderer');

  Body = require('./Body');

  gameConfig = require('../config');

  templates = {
    svg: {
      rect: "partials/svg-rect",
      circle: "partials/svg-circle",
      poly: "partials/svg-poly"
    }
  };

  /*
  ## Wall class
  
  A physical Body (Game item) which shape gets rendered on screen in an SVG path element of a fixed
  color
  
  Read Walls for more about the way a Wall is added to the scene and handled Walls support all
  shape types (`type`) that Body supports
  
  Read Body for more
  */


  Wall = (function(_super) {
    __extends(Wall, _super);

    Wall.prototype.itemType = 'wall';

    function Wall(options, world, wrap, color) {
      this.world = world;
      this.wrap = wrap;
      this.color = color != null ? color : gameConfig.wallsColor;
      options.interaction = 'static';
      Wall.__super__.constructor.apply(this, arguments);
      this.render();
    }

    Wall.prototype.render = function() {
      var ctx, point, x, y, _i, _len, _ref;
      ctx = {
        x: this.viewport.worldToScreen(this.x),
        y: this.viewport.worldToScreen(this.y),
        fill: this.color
      };
      if (this.type === 'rect') {
        ctx.width = this.viewport.worldToScreen(this.width);
        ctx.height = this.viewport.worldToScreen(this.height);
        ctx.x -= ctx.width / 2;
        ctx.y -= ctx.height / 2;
      } else if (this.type === 'circle') {
        ctx.radius = this.viewport.worldToScreen(this.radius);
      } else if (this.type === 'poly') {
        ctx.points = [];
        _ref = this.points;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          point = _ref[_i];
          x = (this.viewport.worldToScreen(point[0])) + ctx.x;
          y = (this.viewport.worldToScreen(point[1])) + ctx.y;
          ctx.points.push("" + x + "," + y);
        }
        ctx.points = ctx.points.join(' ');
      }
      this.el = $(renderer.render(templates.svg[this.type], ctx));
      return this.el.appendTo(this.wrap);
    };

    return Wall;

  })(Body);

  module.exports = Wall;

}).call(this);

},{"../../core/renderer":5,"../config":27,"./Body":31}],35:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
(function() {
  var SpriteRenderer, assets, renderer, templates;

  renderer = require('../../core/renderer');

  assets = require('./assets');

  templates = {
    sprite: 'partials/game-sprite'
  };

  /*
  ## Sprite Renderer
  
  Takes care of the DOM rendering and manipulation, updating and animating of Sprites Initialise
  with a preset
  
  Presets are defined in www/game/sprites.json and loaded throught the GameData module
  */


  SpriteRenderer = (function() {
    function SpriteRenderer(preset, viewport) {
      this.preset = preset;
      this.viewport = viewport;
      this.assets = this.preset.assets;
      this.poses = this.preset.poses;
      this.make();
    }

    SpriteRenderer.prototype.render = function() {
      var asset, assetPath;
      this.el = $(renderer.render(templates.sprite));
      asset = this.assets[this.poses[this.pose].assets || 'default'];
      assetPath = assets.getAssetPath(asset);
      return this.el.css({
        width: Math.floor(this.viewport.worldToScreen(this.poses[this.pose].module[0])),
        height: Math.floor(this.viewport.worldToScreen(this.poses[this.pose].module[1])),
        backgroundImage: "url(" + assetPath + ")",
        backgroundSize: "" + (Math.floor(this.width)) + "px " + (Math.floor(this.height)) + "px",
        backgroundPosition: "-" + this.offset.x + "px -" + this.offset.y + "px"
      });
    };

    SpriteRenderer.prototype.make = function() {
      this.width = this.viewport.worldToScreen(this.preset.size[0] || 0);
      this.height = this.viewport.worldToScreen(this.preset.size[1] || 0);
      if (this.preset.offset != null) {
        this.offset = {
          x: this.preset.offset[0],
          y: this.preset.offset[1]
        };
      } else {
        this.offset = {
          x: 0,
          y: 0
        };
      }
      this.offset = this.viewport.worldToScreen(this.offset);
      this.pose = 'default';
      this.frame = 0;
      return this.extendPoses();
    };

    SpriteRenderer.prototype.getPose = function() {
      return this.poses[this.pose];
    };

    SpriteRenderer.prototype.extendPoses = function() {
      var pose, poseId, _ref, _results;
      _ref = this.poses;
      _results = [];
      for (poseId in _ref) {
        pose = _ref[poseId];
        _results.push((function() {
          var _results1;
          _results1 = [];
          while (pose["extends"] != null) {
            _results1.push(this.extendPose(poseId, pose));
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    SpriteRenderer.prototype.extendPose = function(poseId, pose) {
      var basePoseId;
      if (pose["extends"] != null) {
        basePoseId = pose["extends"];
        delete pose["extends"];
        return this.poses[poseId] = $.extend({}, this.poses[basePoseId], pose);
      }
    };

    return SpriteRenderer;

  })();

  module.exports = SpriteRenderer;

}).call(this);

},{"../../core/renderer":5,"./assets":37}],36:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
/*
## Achievements module

Manager for achievements data, displays notifications when an achievement is
unlocked from another module class
*/


(function() {
  var achievements, achievementsData, conf, notificationsWrap, renderer, selectors, templates, unlocked, userData;

  userData = require('./userData');

  renderer = require('../../core/renderer');

  notificationsWrap = $('#notifications-wrap');

  selectors = {
    notification: '.achievement-notification'
  };

  templates = {
    notification: 'partials/achievement-notification'
  };

  conf = {
    notificationMargin: 10,
    transitionDuration: 300,
    notificationPersistance: 2500
  };

  if (localStorage.achievementsData != null) {
    achievementsData = JSON.parse(localStorage.achievementsData);
  } else {
    achievementsData = {};
  }

  unlocked = userData.getUnlockedAchievements();

  achievements = {
    novice: {
      title: 'Novice',
      description: 'Complete a level'
    },
    champion: {
      title: 'Champion',
      description: 'Complete the game'
    },
    master: {
      title: 'Master',
      description: 'Complete all levels with 3 stars'
    },
    hacker: {
      title: 'All Stars',
      description: 'Complete a level with shots left'
    },
    fryup: {
      title: 'Fry-up',
      description: 'Get burned by lasers 10 times'
    }
  };

  module.exports = window.a = {
    isUnlocked: function(id) {
      return (unlocked.indexOf(id)) !== -1;
    },
    unlock: function(id) {
      if (!this.isUnlocked(id)) {
        unlocked.push(id);
        userData.storeUnlockedAchievements(unlocked);
        return this.displayAchievement(id);
      }
    },
    displayAchievement: function(id) {
      var achievement, ctx, el,
        _this = this;
      achievement = achievements[id];
      ctx = {
        id: id,
        title: achievement.title,
        description: achievement.description
      };
      el = $(renderer.render(templates.notification, ctx));
      el.css({
        opacity: 0,
        top: -100
      });
      notificationsWrap.append(el);
      return el.transition({
        opacity: 1,
        top: 0
      }, conf.transitionDuration, function() {
        return setTimeout((function() {
          return el.transition({
            opacity: 0,
            top: -100
          }, conf.transitionDuration, function() {
            return el.remove();
          });
        }), conf.notificationPersistance);
      });
    },
    getData: function(key) {
      return achievementsData[key] || null;
    },
    storeData: function(data) {
      $.extend(achievementsData, data);
      return localStorage.achievementsData = JSON.stringify(achievementsData);
    },
    getAll: function() {
      var achievement, id, out;
      out = $.extend(true, {}, achievements);
      for (id in out) {
        achievement = out[id];
        achievement.id = id;
        achievement.unlocked = (unlocked.indexOf(id)) !== -1;
      }
      return out;
    }
  };

}).call(this);

},{"../../core/renderer":5,"./userData":40}],37:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
/*
## Assets module

Serves assets filenames depending on configuration and device pixel density
*/


(function() {
  var config, device, pr;

  device = require('../../core/device');

  pr = device.getPixelRatio();

  config = {
    suffix: pr === 1 ? '' : "@" + pr + "x",
    assetsDir: 'assets',
    ext: 'png'
  };

  module.exports = {
    getAssetPath: function(asset, ext) {
      if (ext == null) {
        ext = ext;
      }
      return "" + config.assetsDir + "/" + asset + config.suffix + "." + config.ext;
    }
  };

}).call(this);

},{"../../core/device":4}],38:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
/*
## Game Data module

Handles the loading and storing of the JSON game assets

The assets used are located in www/game/ and they are:
1. `levels.json`: *Index of all levels*
2. `levels/[level-name].json`: *Level maps*
3. `materials.json`: *Contains all materials properties*
4. `sprites.json`: *All sprite presets*
5. `presets.json`: *All entity presets*
*/


(function() {
  var baseDir, gameConfig, gameData, ready, readyCallbacks;

  gameConfig = require('../config');

  baseDir = gameConfig.gameDataPath;

  gameData = {
    sprites: {},
    materials: {},
    levels: []
  };

  ready = false;

  readyCallbacks = [];

  module.exports = {
    init: function() {
      return this.loadData(['sprites', 'materials', 'presets', 'levels', 'tutorials'], function() {
        var cb, _i, _len, _results;
        ready = true;
        _results = [];
        for (_i = 0, _len = readyCallbacks.length; _i < _len; _i++) {
          cb = readyCallbacks[_i];
          _results.push(cb());
        }
        return _results;
      });
    },
    get: function(type, id) {
      if (!_.has(gameData, type)) {
        throw "GameData error: No data for '" + type + "'";
      }
      if (id == null) {
        return gameData[type];
      }
      if (!_.has(gameData[type], id)) {
        throw "GameData error: '" + type + "' does not contain '" + id + "'";
      }
      return gameData[type][id];
    },
    onReady: function(cb) {
      if (ready) {
        return cb();
      } else {
        return readyCallbacks.push(cb);
      }
    },
    loadLevel: function(id, callback) {
      return $.getJSON("" + baseDir + "/levels/" + id + ".json", function(level) {
        if (typeof callback === 'function') {
          return callback(level);
        }
      }).fail(function(req, err) {
        throw "Error loading level: " + id + ".json - " + err;
      });
    },
    loadData: function(nsArr, callback) {
      var loaded, ns, _i, _len, _results,
        _this = this;
      loaded = 0;
      _results = [];
      for (_i = 0, _len = nsArr.length; _i < _len; _i++) {
        ns = nsArr[_i];
        _results.push((function(ns) {
          return $.getJSON("" + baseDir + "/" + ns + ".json", function(data) {
            gameData[ns] = data;
            _this.solveInheritances(ns);
            loaded++;
            if (loaded === nsArr.length && typeof callback === 'function') {
              return callback(data);
            }
          }).fail(function(req, err) {
            throw "Error loading game data: " + ns + ".json - " + err;
          });
        })(ns));
      }
      return _results;
    },
    solveInheritances: function(ns) {
      var item, itemId, _ref, _results;
      _ref = gameData[ns];
      _results = [];
      for (itemId in _ref) {
        item = _ref[itemId];
        _results.push(item = this.solveInheritance(ns, itemId));
      }
      return _results;
    },
    solveInheritance: function(ns, id) {
      var extendFrom;
      while (gameData[ns][id]["extends"] != null) {
        extendFrom = gameData[ns][id]["extends"];
        gameData[ns][id]["extends"] = null;
        gameData[ns][id] = $.extend({}, this.get(ns, extendFrom), gameData[ns][id]);
      }
      return gameData[ns][id];
    }
  };

}).call(this);

},{"../config":27}],39:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
/*
## Physics module

Wraps Box2D (Box2DWeb port) into a simpler API, defines a layer of separation from the actual port
that would allow me to simply replace it with a different port/library

Gets me all I need from Box2D and hides complexity from it
*/


(function() {
  var bodyDefaults, gameData;

  gameData = require('../utils/gameData');

  bodyDefaults = {
    interaction: 'dynamic',
    mat: 'default'
  };

  module.exports = {
    ratio: 30,
    Vector: Box2D.Common.Math.b2Vec2,
    World: Box2D.Dynamics.b2World,
    Body: Box2D.Dynamics.b2Body,
    BodyDef: Box2D.Dynamics.b2BodyDef,
    FixtureDef: Box2D.Dynamics.b2FixtureDef,
    dynamicBody: Box2D.Dynamics.b2Body.b2_dynamicBody,
    staticBody: Box2D.Dynamics.b2Body.b2_staticBody,
    kinematicBody: Box2D.Dynamics.b2Body.b2_kinematicBody,
    ContactListener: Box2D.Dynamics.b2ContactListener,
    shapes: {
      Circle: Box2D.Collision.Shapes.b2CircleShape,
      Poly: Box2D.Collision.Shapes.b2PolygonShape
    },
    getVector: function(x, y) {
      return new this.Vector(x * this.ratio, y * this.ratio);
    },
    getBody: function(options) {
      switch (options.type) {
        case 'circle':
          return this.circleBody(options.x, options.y, options.radius, options);
        case 'rect':
          return this.rectBody(options.x, options.y, options.width, options.height, options);
        case 'poly':
          return this.polyBody(options.x, options.y, options.points, options);
        default:
          return null;
      }
    },
    getBodyPosition: function(body) {
      var pos;
      pos = body.m_aabb.GetCenter();
      return {
        x: pos.x * this.ratio,
        y: pos.y * this.ratio
      };
    },
    moveBodyTo: function(body, x, y) {
      var newPos;
      newPos = new this.Vector(x / this.ratio, y / this.ratio);
      return body.m_body.SetPosition(newPos);
    },
    rectBody: function(x, y, width, height, options) {
      var bodyDef, fixtureDef;
      options = $.extend(true, {}, bodyDefaults, options);
      fixtureDef = this.getFixtureDef(new this.shapes.Poly(), options.mat);
      fixtureDef.shape.SetAsBox((width / 2) / this.ratio, (height / 2) / this.ratio);
      bodyDef = this.getBodyDef(x, y, options.interaction, options.mat);
      return {
        bodyDef: bodyDef,
        fixtureDef: fixtureDef
      };
    },
    polyBody: function(x, y, points, options) {
      var bodyDef, fixtureDef, point, vertexes, _i, _len;
      vertexes = [];
      for (_i = 0, _len = points.length; _i < _len; _i++) {
        point = points[_i];
        vertexes.push(new this.Vector(point[0] / this.ratio, point[1] / this.ratio));
      }
      options = $.extend(true, {}, bodyDefaults, options);
      fixtureDef = this.getFixtureDef(new this.shapes.Poly(), options.mat);
      fixtureDef.shape.SetAsArray(vertexes, vertexes.length);
      bodyDef = this.getBodyDef(x, y, options.interaction, options.mat);
      return {
        bodyDef: bodyDef,
        fixtureDef: fixtureDef
      };
    },
    circleBody: function(x, y, rad, options) {
      var bodyDef, fixtureDef;
      options = $.extend(true, {}, bodyDefaults, options);
      fixtureDef = this.getFixtureDef(new this.shapes.Circle(rad / this.ratio), options.mat);
      bodyDef = this.getBodyDef(x, y, options.interaction, options.mat);
      return {
        bodyDef: bodyDef,
        fixtureDef: fixtureDef
      };
    },
    getFixtureDef: function(shape, mat) {
      var fixtureDef, material;
      if (mat == null) {
        mat = 'default';
      }
      material = gameData.get('materials', mat);
      fixtureDef = new this.FixtureDef;
      return _.extend(fixtureDef, material, {
        shape: shape
      });
    },
    getBodyDef: function(x, y, type, mat) {
      var bodyDef, material;
      if (type == null) {
        type = 'dynamic';
      }
      if (mat == null) {
        mat = 'default';
      }
      material = gameData.get('materials', mat);
      bodyDef = new this.BodyDef;
      if (type === 'static') {
        bodyDef.type = this.staticBody;
      } else if (type === 'kinematic') {
        bodyDef.type = this.kinematicBody;
      } else {
        bodyDef.type = this.dynamicBody;
        bodyDef.bullet = true;
      }
      if (material.linearDamping) {
        bodyDef.linearDamping = material.linearDamping;
      }
      bodyDef.position.x = x / this.ratio;
      bodyDef.position.y = y / this.ratio;
      return bodyDef;
    }
  };

}).call(this);

},{"../utils/gameData":38}],40:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
/*
## User Data module

Loads or creates user progress data, takes care of its storage and loading in
the `window.localStorage` object, interacts with the gameData module to get
levels data and normalise user progress
*/


(function() {
  var gameData, getLevelIndexByName, levels, levelsProgress, normaliseLevelsProgress, seenTutorials, unlockedAchievements;

  gameData = require('./gameData');

  levels = [];

  if (localStorage.levelsProgress != null) {
    levelsProgress = JSON.parse(localStorage.levelsProgress);
  } else {
    levelsProgress = [];
  }

  if (localStorage.seenTutorials != null) {
    seenTutorials = JSON.parse(localStorage.seenTutorials);
  } else {
    seenTutorials = [];
  }

  if (localStorage.unlockedAchievements) {
    unlockedAchievements = JSON.parse(localStorage.unlockedAchievements);
  } else {
    unlockedAchievements = [];
  }

  normaliseLevelsProgress = function() {
    var i, level, _i, _len, _results;
    _results = [];
    for (i = _i = 0, _len = levels.length; _i < _len; i = ++_i) {
      level = levels[i];
      if (levelsProgress[i] == null) {
        _results.push(levelsProgress[i] = {
          locked: i === 0 ? false : true,
          completed: false,
          stars: 0
        });
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  getLevelIndexByName = function(name) {
    var i, level, _i, _len;
    for (i = _i = 0, _len = levels.length; _i < _len; i = ++_i) {
      level = levels[i];
      if (level.name === name) {
        return i;
      }
    }
    return null;
  };

  module.exports = {
    getLevelsProgress: function() {
      levels = levels = gameData.get('levels');
      if (levelsProgress.length < levels.length) {
        normaliseLevelsProgress();
      }
      return levelsProgress;
    },
    saveLevelScore: function(levelName, stars) {
      var levelIndex;
      levelIndex = getLevelIndexByName(levelName);
      if (levelIndex != null) {
        levelsProgress[levelIndex].completed = true;
        if (stars > levelsProgress[levelIndex].stars) {
          levelsProgress[levelIndex].stars = stars;
        }
        if (levelsProgress[levelIndex + 1] != null) {
          levelsProgress[levelIndex + 1].locked = false;
        }
        return this.storeLevelsProgress();
      }
    },
    getSeenTutorials: function() {
      return seenTutorials;
    },
    saveSeenTutorial: function(id) {
      if (seenTutorials.indexOf(id === -1)) {
        seenTutorials.push(id);
        return localStorage.seenTutorials = JSON.stringify(seenTutorials);
      }
    },
    storeLevelsProgress: function() {
      return localStorage.levelsProgress = JSON.stringify(levelsProgress);
    },
    getUnlockedAchievements: function() {
      return unlockedAchievements;
    },
    storeUnlockedAchievements: function(data) {
      unlockedAchievements = data;
      return localStorage.unlockedAchievements = JSON.stringify(data);
    }
  };

}).call(this);

},{"./gameData":38}],41:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
/*
## Debug helpers

Debugging tools
*/


(function() {
  var createDebugCtx, initPhysicsDebugger;

  createDebugCtx = function(wrap, width, height) {
    var canvas;
    canvas = $("<canvas width='" + width + "' height='" + height + "'></canvas>");
    canvas.css({
      position: 'absolute',
      left: 0,
      top: 0
    });
    wrap.prepend(canvas);
    return canvas[0].getContext('2d');
  };

  initPhysicsDebugger = function(world) {
    var canvas, ctx, debugDraw, height, width;
    width = world.viewport.worldToScreen(world.viewport.width);
    height = world.viewport.worldToScreen(world.viewport.height);
    ctx = createDebugCtx(world.viewport.el, width, height);
    canvas = $(ctx.canvas);
    debugDraw = new Box2D.Dynamics.b2DebugDraw;
    debugDraw.SetSprite(ctx);
    debugDraw.SetDrawScale(17);
    debugDraw.SetFillAlpha(0.3);
    debugDraw.SetLineThickness(1.0);
    debugDraw.SetFlags(Box2D.Dynamics.b2DebugDraw.e_shapeBit || Box2D.Dynamics.b2DebugDraw.e_jointBit);
    world.b2dWorld.SetDebugDraw(debugDraw);
    world.loop.use(function() {
      return world.b2dWorld.DrawDebugData();
    });
    return debugDraw;
  };

  module.exports = {
    initPhysicsDebugger: initPhysicsDebugger
  };

}).call(this);

},{}],42:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
/*
## DOM helpers

Common functions and utilities for DOM manipulation
*/


(function() {
  module.exports = {
    getByRole: function(role, parent, filter) {
      var selector;
      if (parent == null) {
        parent = null;
      }
      if (filter == null) {
        filter = '';
      }
      selector = "[data-role='" + role + "']" + filter;
      if (parent == null) {
        return $(selector);
      } else {
        return parent.find(selector);
      }
    }
  };

}).call(this);

},{}],43:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
(function() {
  var BaseModal, device, renderer, selectors, templates, transitionTime;

  renderer = require('../../core/renderer');

  device = require('../../core/device');

  transitionTime = 200;

  selectors = {
    inner: '.modal',
    overlay: '.overlay'
  };

  templates = {
    modal: 'partials/modal'
  };

  /*
  ## Base Modal class
  
  Extend this class to create a custom modal.
  Instanciate the class to render and open the modal
  
  Class-based modals may not necessarily be a great idea,
  but hey, I wanted to try a new approach.
  Deal with it.
  */


  BaseModal = (function() {
    BaseModal.prototype.templateName = 'partials/modal-foo';

    BaseModal.prototype.classNames = '';

    BaseModal.prototype.showClose = true;

    function BaseModal(wrap, context, options) {
      this.wrap = wrap;
      this.context = context;
      if (options == null) {
        options = {};
      }
      this.onClose = options.onClose || null;
      this.onOpen = options.onOpen || null;
      if (options.templateName) {
        this.templateName = options.templateName;
      }
      if (options.classNames) {
        this.classNames = options.classNames;
      }
      this.open();
    }

    BaseModal.prototype.render = function() {
      var body, context;
      body = renderer.render(this.templateName, this.context);
      context = $.extend(this.context, {
        body: body,
        'show-close': this.showClose
      });
      this.el = $(renderer.render(templates.modal, context));
      this.overlay = this.el.find(selectors.overlay);
      this.inner = this.el.find(selectors.inner);
      return this.inner.addClass(this.classNames);
    };

    BaseModal.prototype.open = function() {
      var _this = this;
      this.render();
      this.overlay.add(this.inner).css({
        opacity: 0
      });
      this.el.appendTo(this.wrap);
      this.inner.css({
        x: (this.wrap.width() - this.inner.outerWidth()) / 2,
        y: (this.wrap.height() - this.inner.outerHeight()) / 2,
        scale: .5
      });
      this.overlay.transition({
        opacity: 1
      }, transitionTime / 2);
      return this.inner.transition({
        scale: 1,
        opacity: 1
      }, transitionTime, function() {
        _this.bind();
        if (_this.onOpen != null) {
          return _this.onOpen(_this);
        }
      });
    };

    BaseModal.prototype.bind = function() {
      var _this = this;
      return this.inner.on(device.getEvent('mousedown'), '[data-role="close"]', function(e) {
        e.preventDefault();
        return _this.close();
      });
    };

    BaseModal.prototype.close = function(callback) {
      var _this = this;
      this.overlay.transition({
        opacity: 0
      }, transitionTime / 2);
      return this.inner.transition({
        scale: .5,
        opacity: 0
      }, transitionTime, function() {
        _this.el.remove();
        if (_this.onClose != null) {
          return _this.onClose(_this);
        }
      });
    };

    return BaseModal;

  })();

  module.exports = BaseModal;

}).call(this);

},{"../../core/device":4,"../../core/renderer":5}],44:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
(function() {
  var BaseModal, EndGameModal, animationsDelay, device, gameData, selectors, views,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  BaseModal = require('./BaseModal');

  device = require('../../core/device');

  views = require('../../core/views');

  gameData = require('../../game/utils/gameData');

  animationsDelay = 600;

  selectors = {
    star: '.star'
  };

  /*
  ## End of Game Modal class
  
  Shown at the end of every game
  Displays a different set of elements and actions depending on the outcome of the game
  
  Read BaseModal for more
  */


  EndGameModal = (function(_super) {
    __extends(EndGameModal, _super);

    EndGameModal.prototype.templateName = 'partials/modal-end-game';

    EndGameModal.prototype.classNames = 'modal-end-game';

    EndGameModal.prototype.showClose = false;

    function EndGameModal(wrap, context, options) {
      var i, level, levels, _i, _len;
      this.wrap = wrap;
      this.context = context;
      if (options == null) {
        options = {};
      }
      this.game = options.game;
      this.starsCount = options.stars;
      this.levelName = options.levelName;
      levels = gameData.get('levels');
      this.nextLevel = null;
      for (i = _i = 0, _len = levels.length; _i < _len; i = ++_i) {
        level = levels[i];
        if (level.name === this.levelName) {
          this.level = levels[i];
          if (levels[i + 1]) {
            this.nextLevel = levels[i + 1];
          }
          break;
        }
      }
      this.context['next-level'] = this.nextLevel;
      EndGameModal.__super__.constructor.apply(this, arguments);
    }

    EndGameModal.prototype.bind = function() {
      var _this = this;
      EndGameModal.__super__.bind.apply(this, arguments);
      this.inner.on(device.getEvent('mousedown'), '[data-role="restart"]', function(e) {
        _this.game.restart();
        return e.preventDefault();
      });
      this.inner.on(device.getEvent('mousedown'), '[data-role="next"]', function(e) {
        _this.openNextLevel();
        return e.preventDefault();
      });
      this.inner.on(device.getEvent('mousedown'), '[data-role="back"]', function(e) {
        views.open('levels', 'slide-left');
        return e.preventDefault();
      });
      return this.addStars();
    };

    EndGameModal.prototype.openNextLevel = function() {
      return views.open('game', 'slide-right', null, false, this.nextLevel.name);
    };

    EndGameModal.prototype.addStars = function() {
      var i, _i, _ref, _results,
        _this = this;
      this.stars = this.inner.find(selectors.star);
      this.addedStars = 0;
      this.animatedStars = 0;
      _results = [];
      for (i = _i = 0, _ref = this.starsCount; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        _results.push(setTimeout((function() {
          return _this.addStar();
        }), animationsDelay / 3 * i));
      }
      return _results;
    };

    EndGameModal.prototype.addStar = function() {
      var el,
        _this = this;
      el = this.stars.eq(this.addedStars);
      if (el == null) {
        return;
      }
      el.css({
        scale: 4
      });
      this.addedStars++;
      return el.transition({
        opacity: 1,
        scale: 1
      }, animationsDelay, function() {
        _this.animatedStars++;
        if (_this.animatedStars === _this.starsCount) {
          return _this.starsAdded();
        }
      });
    };

    EndGameModal.prototype.starsAdded = function() {};

    return EndGameModal;

  })(BaseModal);

  module.exports = EndGameModal;

}).call(this);

},{"../../core/device":4,"../../core/views":7,"../../game/utils/gameData":38,"./BaseModal":43}],45:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
(function() {
  var BaseModal, PauseModal, device, views,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  BaseModal = require('./BaseModal');

  device = require('../../core/device');

  views = require('../../core/views');

  /*
  ## Pause Modal class
  
  Modal shown when pausing
  Read BaseModal for more
  */


  PauseModal = (function(_super) {
    __extends(PauseModal, _super);

    PauseModal.prototype.templateName = 'partials/modal-pause';

    PauseModal.prototype.classNames = 'modal-pause';

    PauseModal.prototype.showClose = false;

    function PauseModal(wrap, context, options) {
      this.wrap = wrap;
      this.context = context;
      if (options == null) {
        options = {};
      }
      this.game = options.game;
      this.levelName = options.levelName;
      this.game.world.stop();
      PauseModal.__super__.constructor.apply(this, arguments);
    }

    PauseModal.prototype.bind = function() {
      var _this = this;
      PauseModal.__super__.bind.apply(this, arguments);
      this.inner.on(device.getEvent('mousedown'), '[data-role="restart"]', function(e) {
        _this.game.restart();
        return e.preventDefault();
      });
      this.inner.on(device.getEvent('mousedown'), '[data-role="resume"]', function(e) {
        _this.close();
        _this.game.world.play();
        return e.preventDefault();
      });
      return this.inner.on(device.getEvent('mousedown'), '[data-role="back"]', function(e) {
        views.open('levels', 'slide-left');
        return e.preventDefault();
      });
    };

    return PauseModal;

  })(BaseModal);

  module.exports = PauseModal;

}).call(this);

},{"../../core/device":4,"../../core/views":7,"./BaseModal":43}],46:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
(function() {
  var BaseModal, TutorialModal, device, gameData, userData,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  BaseModal = require('./BaseModal');

  device = require('../../core/device');

  userData = require('../../game/utils/userData');

  gameData = require('../../game/utils/gameData');

  /*
  ## Tutorial Modal class
  
  Shown once with custom message
  */


  TutorialModal = (function(_super) {
    __extends(TutorialModal, _super);

    TutorialModal.prototype.templateName = 'partials/modal-tutorial';

    TutorialModal.prototype.classNames = 'modal-tutorial';

    function TutorialModal(wrap, id) {
      this.wrap = wrap;
      this.id = id;
      this.context = gameData.get('tutorials', this.id);
      if ((userData.getSeenTutorials().indexOf(this.id)) === -1) {
        TutorialModal.__super__.constructor.call(this, this.wrap, this.context);
      }
    }

    TutorialModal.prototype.bind = function() {
      var _this = this;
      TutorialModal.__super__.bind.apply(this, arguments);
      return this.inner.on(device.getEvent('click'), '[data-role="done"]', function(e) {
        _this.done();
        return e.preventDefault();
      });
    };

    TutorialModal.prototype.done = function() {
      userData.saveSeenTutorial(this.id);
      return this.close();
    };

    return TutorialModal;

  })(BaseModal);

  module.exports = TutorialModal;

}).call(this);

},{"../../core/device":4,"../../game/utils/gameData":38,"../../game/utils/userData":40,"./BaseModal":43}],47:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
/*
## Touchables

This module binds to the device-specific click event to add a .touch-active pseudo-class for
a set duration after triggering It's applied to the targeted selectors and used to customise visual
feedback when elemements are tapped
*/


(function() {
  var activeStateDuration, classNames, device, touchables;

  device = require('../core/device');

  touchables = 'a, .button, button, input, .touchable';

  classNames = {
    touchActive: 'touch-active'
  };

  activeStateDuration = 200;

  module.exports = {
    initialise: function() {
      return this.bind();
    },
    bind: function() {
      var self;
      self = this;
      return $('body').on(device.getEvent('click'), touchables, function() {
        return self.onClick($(this));
      });
    },
    onClick: function(element) {
      var _this = this;
      element.addClass(classNames.touchActive);
      return element.data('touchActiveTimer', setTimeout(function() {
        element.removeClass(classNames.touchActive);
        if (element.data('touchActiveTimer') != null) {
          return clearTimeout(element.data('touchActiveTimer'));
        }
      }, activeStateDuration));
    }
  };

}).call(this);

},{"../core/device":4}],48:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
(function() {
  var AchievementsView, BaseView, achievements, device, getByRole, views, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  BaseView = require('../core/BaseView');

  device = require('../core/device');

  views = require('../core/views');

  getByRole = (require('../helpers/dom')).getByRole;

  achievements = require('../game/utils/achievements');

  /*
  ## Achievements View class
  
  Shows available and unlocked achievements
  */


  AchievementsView = (function(_super) {
    __extends(AchievementsView, _super);

    function AchievementsView() {
      _ref = AchievementsView.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    AchievementsView.prototype.templateName = 'achievements';

    AchievementsView.prototype.classNames = 'view-achievements';

    AchievementsView.prototype.fixHeight = true;

    AchievementsView.prototype.render = function(wrapper) {
      this.context.achievements = achievements.getAll();
      return AchievementsView.__super__.render.apply(this, arguments);
    };

    AchievementsView.prototype.getElements = function() {
      AchievementsView.__super__.getElements.apply(this, arguments);
      return this.elements.nav = {
        home: getByRole('nav-home', this.elements.main)
      };
    };

    AchievementsView.prototype.bind = function() {
      AchievementsView.__super__.bind.apply(this, arguments);
      return this.elements.nav.home.on(device.getEvent('click'), function(e) {
        e.preventDefault();
        return views.open('home', 'slide-left');
      });
    };

    return AchievementsView;

  })(BaseView);

  module.exports = AchievementsView;

}).call(this);

},{"../core/BaseView":2,"../core/device":4,"../core/views":7,"../game/utils/achievements":36,"../helpers/dom":42}],49:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
(function() {
  var BaseView, EndGameModal, GameControls, GameView, PauseModal, TutorialModal, World, achievements, debug, device, getByRole, introDuration, phys, userData, views, win,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  BaseView = require('../core/BaseView');

  getByRole = (require('../helpers/dom')).getByRole;

  device = require('../core/device');

  debug = require('../core/debug');

  views = require('../core/views');

  EndGameModal = require('../ui/modals/EndGameModal');

  PauseModal = require('../ui/modals/PauseModal');

  World = require('../game/World');

  GameControls = require('../game/controls/GameControls');

  userData = require('../game/utils/userData');

  phys = require('../game/utils/physics');

  achievements = require('../game/utils/achievements');

  TutorialModal = require('../ui/modals/TutorialModal');

  win = $(window);

  introDuration = debug.skipAnimations ? 0 : 2400;

  /*
  ## Game View class
  
  Loads a level's data, wraps, initialises and runs game logic
  */


  GameView = (function(_super) {
    __extends(GameView, _super);

    GameView.prototype.templateName = 'game';

    GameView.prototype.classNames = 'view-game';

    GameView.prototype.fixHeight = true;

    function GameView(levelName) {
      this.levelName = levelName;
      GameView.__super__.constructor.apply(this, arguments);
      this.shots = null;
      this.targetsCount = null;
      this.stars = 3;
      this.finished = false;
    }

    GameView.prototype.getElements = function() {
      GameView.__super__.getElements.apply(this, arguments);
      this.elements.pause = getByRole('pause', this.elements.main);
      this.elements.reset = getByRole('reset', this.elements.main);
      return this.elements.shots = getByRole('shots-counter', this.elements.main);
    };

    GameView.prototype.bind = function() {
      var _this = this;
      GameView.__super__.bind.apply(this, arguments);
      window.scrollTo(0, 0);
      this.world = new World(this.elements.main, this.levelName);
      this.elements.reset.on(device.getEvent('mousedown'), function(e) {
        return _this.restart();
      });
      this.elements.pause.on(device.getEvent('mousedown'), function(e) {
        var context, options;
        context = {
          title: 'Pause'
        };
        options = {
          game: _this,
          levelName: _this.levelName
        };
        new PauseModal(_this.elements.main, context, options);
        return e.preventDefault();
      });
      (_(this.world)).on('shoot', function() {
        return _this.setShots(_this.shots - 1);
      });
      (_(this.world)).on('pot', function() {
        return _this.setTargetsCount(_this.targetsCount - 1);
      });
      return ($(document)).on("touchmove", this.onTouchMove);
    };

    GameView.prototype.onTouchMove = function(e) {
      window.scrollTo(0, 0);
      return e.preventDefault();
    };

    GameView.prototype.resize = function() {
      GameView.__super__.resize.apply(this, arguments);
      if (this.world != null) {
        return this.world.viewport.resize();
      }
    };

    GameView.prototype.restart = function() {
      return views.open('game', null, null, false, this.levelName);
    };

    GameView.prototype.transitionComplete = function() {
      var _this = this;
      GameView.__super__.transitionComplete.apply(this, arguments);
      return this.world.onReady(function() {
        return _this.startGame();
      });
    };

    GameView.prototype.startGame = function() {
      var tutorial,
        _this = this;
      this.world.play();
      tutorial = this.world.level.data.tutorial;
      if (tutorial) {
        new TutorialModal(this.elements.main, tutorial);
      }
      this.player = this.world.getItemById('player');
      this.targets = this.world.getItemsByAttr('type', 'target');
      (_(this.player)).on('die', function() {
        return _this.finish(false);
      });
      this.setShots(this.world.level.data.shots);
      this.setTargetsCount(this.targets.length);
      return this.showIntro(function() {
        return _this.enableControls();
      });
    };

    GameView.prototype.setTargetsCount = function(amt) {
      this.targetsCount = amt;
      if (amt === 0) {
        return this.finish(true);
      }
    };

    GameView.prototype.finish = function(win) {
      var context, modalTitle, options;
      if (win == null) {
        win = false;
      }
      this.player.behaviour.win();
      if (!this.finished) {
        this.finished = true;
        modalTitle = win ? "Level " + this.levelName + " Complete!" : "Ouch!";
        context = {
          win: win,
          title: modalTitle
        };
        options = {
          stars: this.stars,
          game: this,
          levelName: this.levelName
        };
        if (win) {
          userData.saveLevelScore(this.levelName, this.stars);
          this.checkWinningAchievements();
        }
        return new EndGameModal(this.elements.main, context, options);
      }
    };

    GameView.prototype.checkWinningAchievements = function() {
      var allCompleted, allStars, level, progress, _i, _len;
      progress = userData.getLevelsProgress();
      allCompleted = true;
      allStars = true;
      achievements.unlock('novice');
      if (this.shots > 0) {
        achievements.unlock('hacker');
      }
      for (_i = 0, _len = progress.length; _i < _len; _i++) {
        level = progress[_i];
        if (!level.completed) {
          allCompleted = false;
          allStars = false;
        } else if (level.stars < 3) {
          allStars = false;
        }
      }
      if (allCompleted) {
        localStorage.gameCompleted = true;
        achievements.unlock('champion');
      }
      if (allStars) {
        return achievements.unlock('master');
      }
    };

    GameView.prototype.setShots = function(amt) {
      this.shots = amt;
      if (amt < -2) {
        this.setStars(0);
      } else if (amt < -1) {
        this.setStars(1);
      } else if (amt < 0) {
        this.setStars(2);
      }
      return this.elements.shots.text(amt);
    };

    GameView.prototype.setStars = function(amt) {
      if (this.stars !== amt) {
        this.elements.shots.removeClass("stars-" + this.stars);
        this.stars = amt;
        return this.elements.shots.addClass("stars-" + this.stars);
      }
    };

    GameView.prototype.enableControls = function() {
      var _this = this;
      this.world.loop.use(function() {
        return _this.update();
      });
      this.controls = new GameControls(this);
      return this.controls.on();
    };

    GameView.prototype.showIntro = function(callback) {
      var _this = this;
      this.viewportFits = this.world.viewport.fits();
      if (!this.viewportFits) {
        return this.world.viewport.followEntity(this.targets[0], introDuration / 2, function() {
          return _this.world.viewport.followEntity(_this.player, introDuration / 2, function() {
            return callback();
          });
        });
      } else {
        return callback();
      }
    };

    GameView.prototype.unbind = function() {
      this.elements.pause.off(device.getEvent('click'));
      this.elements.reset.off(device.getEvent('click'));
      return ($(document)).off("touchmove", this.onTouchMove);
    };

    GameView.prototype.close = function() {
      GameView.__super__.close.apply(this, arguments);
      if (this.controls != null) {
        this.controls.off();
      }
      if (this.world != null) {
        return this.world.stop();
      }
    };

    GameView.prototype.update = function() {
      if (!this.viewportFits) {
        return this.world.viewport.followEntity(this.player);
      }
    };

    return GameView;

  })(BaseView);

  module.exports = GameView;

}).call(this);

},{"../core/BaseView":2,"../core/debug":3,"../core/device":4,"../core/views":7,"../game/World":8,"../game/controls/GameControls":28,"../game/utils/achievements":36,"../game/utils/physics":39,"../game/utils/userData":40,"../helpers/dom":42,"../ui/modals/EndGameModal":44,"../ui/modals/PauseModal":45,"../ui/modals/TutorialModal":46}],50:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
(function() {
  var BaseView, HomeView, device, gameData, getByRole, userData, views, win,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  BaseView = require('../core/BaseView');

  device = require('../core/device');

  views = require('../core/views');

  getByRole = (require('../helpers/dom')).getByRole;

  userData = require('../game/utils/userData');

  gameData = require('../game/utils/gameData');

  win = $(window);

  /*
  ## Home View class
  
  The first view shown when the app is started
  */


  HomeView = (function(_super) {
    __extends(HomeView, _super);

    HomeView.prototype.templateName = 'home';

    HomeView.prototype.classNames = 'view-home';

    HomeView.prototype.fixHeight = true;

    function HomeView(levelName) {
      this.levelName = levelName;
      HomeView.__super__.constructor.apply(this, arguments);
    }

    HomeView.prototype.getElements = function() {
      HomeView.__super__.getElements.apply(this, arguments);
      return this.elements.nav = {
        play: getByRole('nav-play', this.elements.main),
        levels: getByRole('nav-levels', this.elements.main),
        achievements: getByRole('nav-achievements', this.elements.main)
      };
    };

    HomeView.prototype.bind = function() {
      var nextLevel;
      HomeView.__super__.bind.apply(this, arguments);
      nextLevel = this.getNextLevel();
      this.elements.nav.play.on(device.getEvent('click'), function(e) {
        e.preventDefault();
        return views.open('game', 'pop-out', null, false, nextLevel.name);
      });
      this.elements.nav.levels.on(device.getEvent('click'), function(e) {
        e.preventDefault();
        return views.open('levels', 'slide-right');
      });
      return this.elements.nav.achievements.on(device.getEvent('click'), function(e) {
        e.preventDefault();
        return views.open('achievements', 'slide-right');
      });
    };

    HomeView.prototype.getNextLevel = function() {
      var i, level, levelIndex, levels, progress, _i, _len;
      levelIndex = null;
      progress = userData.getLevelsProgress();
      for (i = _i = 0, _len = progress.length; _i < _len; i = ++_i) {
        level = progress[i];
        if (level.locked) {
          break;
        }
        levelIndex = i;
      }
      levels = gameData.get('levels');
      return levels[levelIndex];
    };

    return HomeView;

  })(BaseView);

  module.exports = HomeView;

}).call(this);

},{"../core/BaseView":2,"../core/device":4,"../core/views":7,"../game/utils/gameData":38,"../game/utils/userData":40,"../helpers/dom":42}],51:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
(function() {
  var BaseModal, BaseView, LevelsView, device, gameData, getByRole, renderer, selectors, templates, userData, viewWrap, views,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  BaseView = require('../core/BaseView');

  views = require('../core/views');

  device = require('../core/device');

  renderer = require('../core/renderer');

  getByRole = (require('../helpers/dom')).getByRole;

  gameData = require('../game/utils/gameData');

  userData = require('../game/utils/userData');

  BaseModal = require('../ui/modals/BaseModal');

  selectors = {
    locked: '.locked'
  };

  templates = {
    gameCompletionModal: 'partials/modal-completed-game'
  };

  viewWrap = $('#view-wrap');

  /*
  ## Levels View
  
  View containing information about user progress and levels navigation
  */


  LevelsView = (function(_super) {
    __extends(LevelsView, _super);

    LevelsView.prototype.templateName = 'levels';

    LevelsView.prototype.fixHeight = true;

    LevelsView.prototype.classNames = 'view-levels';

    function LevelsView() {
      this.bind = __bind(this.bind, this);
      this.getElements = __bind(this.getElements, this);
      var i, level, levelsProgress, n, stars, _i, _j, _len, _ref;
      LevelsView.__super__.constructor.apply(this, arguments);
      this.context.levels = [];
      levelsProgress = userData.getLevelsProgress();
      _ref = gameData.get('levels');
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        level = _ref[i];
        stars = [];
        for (n = _j = 0; _j <= 2; n = ++_j) {
          if (levelsProgress[i].stars > n) {
            stars.push({
              scored: true
            });
          } else {
            stars.push({
              scored: false
            });
          }
        }
        this.context.levels.push({
          index: i + 1,
          name: level.name,
          completed: levelsProgress[i].completed,
          perfect: levelsProgress[i] === 3 ? true : false,
          stars: stars,
          locked: levelsProgress[i].locked
        });
      }
    }

    LevelsView.prototype.getElements = function() {
      LevelsView.__super__.getElements.apply(this, arguments);
      this.elements.levels = getByRole('level', this.elements.main);
      return this.elements.nav = {
        home: getByRole('nav-home', this.elements.main)
      };
    };

    LevelsView.prototype.bind = function() {
      var self;
      LevelsView.__super__.bind.apply(this, arguments);
      if (localStorage.gameCompleted && !localStorage.gameCompletionNotified) {
        this.notifyGameCompletion();
      }
      self = this;
      this.elements.levels.not(selectors.locked).on(device.getEvent('click'), function(e) {
        e.preventDefault();
        return self.openLevel(($(this)).attr('data-level-name'));
      });
      return this.elements.nav.home.on(device.getEvent('click'), function(e) {
        e.preventDefault();
        return views.open('home', 'slide-left');
      });
    };

    LevelsView.prototype.notifyGameCompletion = function() {
      var modalContext, modalOptions;
      modalContext = {
        title: 'Well done!',
        icon: 'thumbs-up'
      };
      modalOptions = {
        templateName: templates.gameCompletionModal,
        classNames: 'modal-completed-game'
      };
      new BaseModal(viewWrap, modalContext, modalOptions);
      return localStorage.gameCompletionNotified = true;
    };

    LevelsView.prototype.openLevel = function(levelName) {
      return views.open('game', 'slide-right', null, false, levelName);
    };

    return LevelsView;

  })(BaseView);

  module.exports = LevelsView;

}).call(this);

},{"../core/BaseView":2,"../core/device":4,"../core/renderer":5,"../core/views":7,"../game/utils/gameData":38,"../game/utils/userData":40,"../helpers/dom":42,"../ui/modals/BaseModal":43}]},{},[1])
;